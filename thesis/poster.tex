% Poster get from https://github.com/victorsenam/tcc/blob/master/poster/main.tex

\documentclass[final]{beamer}
\usepackage[size=a1,orientation=portrait,scale=1.3]{beamerposter}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{framed,graphicx,xcolor} % for shaded box
\usepackage{mathtools}%
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,positioning,shadows,trees,patterns}

\usepackage[shortlabels]{enumitem}
\usepackage[numbers]{natbib}
\bibliographystyle{plainnat}
  \def\bibfont{\small}

\sloppy

%----------------------------------------------------------------------------------------
%	SHORTCUTS
%----------------------------------------------------------------------------------------
\newcommand{\B}[1]{\mathbb{#1}}
\newcommand{\Cl}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\sse}{\Leftrightarrow}
\newcommand{\so}{\Rightarrow}
\newcommand{\se}{\Leftarrow}
\newcommand{\rec}{\leftarrow}

\newcommand{\tdots}{\,.\,.\,}

%----------------------------------------------------------------------------------------
%	BEAMER STYLE
%----------------------------------------------------------------------------------------

\usetheme{poster}
\setbeamercolor{block title}{fg=dblue,bg=white}
\setbeamercolor{block body}{fg=black,bg=white}
\setbeamercolor{block alerted title}{fg=dblue,bg=gray!50}
\setbeamercolor{block alerted body}{fg=black,bg=gray!20}
\setbeamercolor{block prob}{fg=black,bg=white}
\setbeamertemplate{caption}[numbered]

%----------------------------------------------------------------------------------------
%	CUSTOM STYLING
%----------------------------------------------------------------------------------------

\newenvironment<>{prob}{
    \begin{beamercolorbox}[sep=1ex,center,dp={1ex}]{block prob}
    \textcolor{dblue}{\textbf{Problema:}}\itshape
}{\end{beamercolorbox}}

\newcommand\halfcol{\column{.46\textwidth}}
\newcommand\onethirdcol{\column{.31\textwidth}}

\newcommand{\Oh}{\mathrm{O}}

% ?????????
\usepackage{subcaption}

\newcommand*\bolinha[1]{\; \tikz[inner sep=.25ex]\node[circle,draw]{#1}; \;}

%----------------------------------------------------------------------------------------
%	POSTER
%----------------------------------------------------------------------------------------

\title{Florestas geradoras maximais de custo
mínimo em grafos dinâmicos}
\author{Chung Jin Shian \hspace{200pt} Orientadora: Cristina Gomes Fernandes}
\institute{\vspace{10pt}Departamento de Ciência da Computação,
Instituto de Matemática e Estatística, Universidade de São Paulo}


\begin{document}
\begin{frame}[fragile]\centering
  \vspace{-40pt}
  \begin{columns}[T]

    % ----------------------------------------------------------------------------------------
    % PRIMEIRA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol
    \begin{alertblock}{Resumo}
      Grafos dinâmicos permitem modelar problemas em que o conjunto de arestas sofre inserções e remoções ao longo do tempo, exigindo estruturas de dados capazes de responder consultas de forma eficiente. Um dos problemas fundamentais nesse contexto é o de conexidade dinâmica, que determina se dois vértices permanecem conectados após atualizações sucessivas. Outro problema central é a manutenção de uma floresta geradora maximal (MSF) decremental, estrutura que mantém, para cada componente conexa do grafo, uma árvore de custo mínimo enquanto suporta apenas remoções de arestas. Neste trabalho, estudamos e implementamos a solução proposta por Holm, de Lichtenberg e Thorup para esses problemas, analisando suas garantias de complexidade e sua adaptação ao cenário decremental, além de descrever a ideia geral do algoritmo para manutenção da MSF dinâmica, que suporta adição e remoção de arestas.
    \end{alertblock}

    \begin{block}{Euler tour trees}
      A Euler tour tree é uma técnica proposta por Thorup et al. na Seção 2.1 de seu artigo, e é utilizada para representar uma árvore. Essa representação é obtida de uma árvore $T$ substituindo-se cada aresta por dois arcos em sentidos opostos e adicionando-se um laço a cada vértice. O digrafo resultante de $T$ é Euleriano, ou seja, é conexo e o grau de entrada de cada vértice é igual ao grau de saída. Consequentemente, há uma trilha que começa e termina num mesmo vértice, passando por todos os arcos do digrafo somente uma vez. Tal trilha é chamada de ciclo Euleriano.
      
      \bigskip
      \begin{figure}[H]
        \centering
        \begin{tikzpicture}[thick, node distance=2cm,
          vtx/.style={draw, circle, minimum size=10mm, inner sep=0pt}]

        % ---------- Left: original graph ----------
        \node[vtx] (a) at (0,0) {$a$};
        \node[vtx] (b) at (1.5,1.5) {$b$};
        \node[vtx] (c) at (3,0) {$c$};
        \node[vtx] (d) at (1.5,-1.5) {$d$};
        \node[vtx] (e) at (-1.5,-1.5) {$e$};

        % Graph edges
        \draw (a) -- (b);
        \draw (c) -- (d);
        \draw (d) -- (a);
        \draw (a) -- (e);

        % ---------- Right: Euler-tour representation ----------
        \begin{scope}[xshift=8cm]
          \node[vtx] (a1) at (0,0) {$a$};
          \node[vtx] (b1) at (1.5, 1.5) {$b$};
          \node[vtx] (c1) at (3,0) {$c$};
          \node[vtx] (d1) at (1.5,-1.5) {$d$};
          \node[vtx] (e1) at (-1.5,-1.5) {$e$};

          % Bidirectional arcs
          \draw[->] (a1) to[bend left=20] (b1);
          \draw[->] (b1) to[bend left=20] (a1);

          \draw[->] (c1) to[bend left=20] (d1);
          \draw[->] (d1) to[bend left=20] (c1);

          \draw[->] (d1) to[bend left=20] (a1);
          \draw[->] (a1) to[bend left=20] (d1);

          \draw[->] (a1) to[bend left=20] (e1);
          \draw[->] (e1) to[bend left=20] (a1);

          \draw[->] (a1) edge[loop above] ();
          \draw[->] (b1) edge[loop above] ();
          \draw[->] (c1) edge[loop right] ();
          \draw[->] (d1) edge[loop below] ();
          \draw[->] (e1) edge[loop left] ();

        \end{scope}

        \end{tikzpicture}
            \caption{À esquerda, temos uma árvore $T$ e, à direita, temos o digrafo Euleriano de $T$.}
            \label{fig:euler-tour-trees}
        \end{figure}

          \begin{figure}[H]
          \centering
          \begin{tikzpicture}
              [node/.style={circle,draw,minimum size=2em, thick, font=\large},
              edge/.style={thick, black},
              reserve/.style={red, thick},
              removed/.style={black, thick, dashed}, 
              inner sep=0pt]

              \node[node] (ad) at (0, 0) {$ad$};
              \node[node] (ab) at (-4.5, -1.5) {$ab$};
              \node[node] (cd) at (4.5, -1.5) {$cd$};
              \node[node] (dc) at (3, -3) {$dc$};
              \node[node] (dd) at (1.5, -4.5) {$dd$};
              \node[node] (cc) at (4.5, -4.5) {$cc$};
              \node[node] (da) at (6, -3) {$da$};
              \node[node] (ae) at (7.5, -4.5) {$ae$};
              
              
              \node[node] (ea) at (-6, -3) {$ea$};
              \node[node] (ee) at (-7.5, -4.5) {$ee$};
              \node[node] (aa) at (-4.5, -4.5) {$aa$};


              \node[node] (bb) at (-3, -3) {$bb$};
              \node[node] (ba) at (-1.5, -4.5) {$ba$};

              

              % tree edges (normal black edges)
              \draw[edge] (ad) -- (ab) node[midway, below] {};
              \draw[edge] (ad) -- (cd) node[midway, below] {};
              \draw[edge] (cd) -- (dc) node[midway, below] {};
              \draw[edge] (cd) -- (da) node[midway, below] {};
              \draw[edge] (bb) -- (ba) node[midway, below] {};
              \draw[edge] (ea) -- (ee) node[midway, below] {};
              \draw[edge] (ea) -- (aa) node[midway, below] {};
              \draw[edge] (dc) -- (dd) node[midway, below] {};
              \draw[edge] (dc) -- (cc) node[midway, below] {};
              \draw[edge] (da) -- (ae) node[midway, below] {};

              \draw[edge] (ab) -- (ea) node[midway, below] {};
              \draw[edge] (ab) -- (bb) node[midway, below] {};

          \end{tikzpicture}
          \caption{Uma árvore binária de busca balanceada para um ciclo Euleriano da árvore da Figura~\ref{fig:euler-tour-trees}. Note que se percorrermos os nós da árvore acima em \textit{inorder}, obtemos a sequência Euleriana de (\ref{eq:euler-sequence}).}
          \label{fig:euler-tour-balanced-tree}
      \end{figure}

    \end{block}

    \begin{block}{Conexidade em florestas dinâmicas}
      O problema da conexidade em florestas dinâmicas é uma simplificação do problema de conexidade em grafos dinâmicos, quando o grafo em questão é uma floresta. Uma floresta dinâmica é constituída de várias ABBBs (na nossa implementação usamos \textit{splay trees}, desenvolvidas por Sleator e Tarjan). Utilizamos as Euler tour trees para representar essas ABBBs da floresta.   

      \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
          \item[$\bullet$] \textbf{\texttt{create\_union(a, b, t)}}: adiciona a união dos conjuntos que contém $a$ e $b$ no instante de tempo $t$
          \item[$\bullet$] \textbf{\texttt{same\_set(a, b, t)}}: consulta se dois elementos pertenciam ao mesmo conjunto no instante $t$
          \item[$\bullet$] \textbf{\texttt{delete\_union(t)}}: desfaz a união realizada em $t$
        \end{itemize}
      \end{shaded}
    \end{block}

    
    % ----------------------------------------------------------------------------------------
    % SEGUNDA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol
    
    \begin{block}{Link-Cut tree}

      % \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      % \begin{shaded}
      %   \textbf{Ideia:} Dividir a floresta em caminhos vértice-disjuntos, chamados \textbf{caminhos preferidos}. Cada um desses caminhos é representado na forma de uma \textit{splay tree}, uma estrutura que permite unir e quebrar estes caminhos de forma bastante eficiente.
      % \end{shaded}

    \end{block}
    \begin{exampleblock}
      

      As link-cut trees fornecem a seguinte interface:

      \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
          \item[$\bullet$] \textbf{\texttt{make\_root(u)}}: enraíza no vértice $u$ a árvore que o contém
          \item[$\bullet$] \textbf{\texttt{link(u, v, w)}}: dado que os vértices $u$ e $v$ estão em árvores separadas, transforma $v$ em raiz de sua árvore e o liga como filho de $u$, colocando peso $w$ na nova aresta criada
          \item[$\bullet$] \textbf{\texttt{cut(u, v)}}: retira da floresta a aresta com pontas em $u$ e $v$, quebrando a árvore que continha estes vértices em duas novas árvores
          \item[$\bullet$] \textbf{\texttt{is\_connected(u, v)}}: retorna \texttt{verdadeiro} caso $u$ e $v$ pertençam à mesma árvore, \texttt{falso} caso contrário
          \item[$\bullet$] \textbf{\texttt{maximum\_edge(u, v)}}: retorna o peso máximo de uma aresta no caminho entre os vértices $u$ e $v$
        \end{itemize}
      \end{shaded}

      Todas essas operações consomem tempo $\Oh(\log n)$ amortizado, onde $n$ é o número de vértices na floresta.

    \end{exampleblock}

    \begin{block}{Union-Find retroativo}

      O union-find é uma estrutura de dados utilizada para manter uma \textbf{coleção de conjuntos disjuntos}, isto é, conjuntos que não se intersectam.

      \bigskip
      \begin{figure}[h!]
        \captionsetup{justification=centering}
        \centering
        \begin{subfigure}{\textwidth}
          \centering
          \begin{tikzpicture}[
              no/.style={shape=circle, minimum size=1cm},
              scale=1.5, transform shape
            ]
            \node[no] (a) at (4,0) {a};
            \node[no] (x) at (5,0) {};
            \node[no] (b) at (6,0) {b};
            \node[no] (y) at (7,0) {};
            \node[no] (c) at (8,0) {c};
            \node[no] (z) at (9,0) {};
            \node[no] (d) at (10,0) {d};

            \draw ($(x)$) ellipse ({1.7cm} and {.7cm});
            \draw ($(c)$) ellipse ({.7cm} and {.7cm});
            \draw ($(d)$) ellipse ({.7cm} and {.7cm});
          \end{tikzpicture}
          \bigskip
        \end{subfigure}
        \begin{subfigure}{\textwidth}
          \centering
          \begin{tikzpicture}[
              no/.style={shape=circle, minimum size=1cm},
              scale=1.5, transform shape
            ]
            \node[no] (a) at (4,0) {a};
            \node[no] (x) at (5,0) {};
            \node[no] (b) at (6,0) {b};
            \node[no] (y) at (7,0) {};
            \node[no] (c) at (8,0) {c};
            \node[no] (z) at (9,0) {};
            \node[no] (d) at (10,0) {d};

            \draw ($(x)$) ellipse ({1.7cm} and {.7cm});
            \draw ($(z)$) ellipse ({1.7cm} and {.7cm});
          \end{tikzpicture}
          \bigskip
        \end{subfigure}
        \begin{subfigure}{\textwidth}
          \centering
          \begin{tikzpicture}[
              no/.style={shape=circle, minimum size=1cm},
              scale=1.5, transform shape
            ]
            \node[no] (a) at (4,0) {a};
            \node[no] (x) at (5,0) {};
            \node[no] (b) at (6,0) {b};
            \node[no] (y) at (7,0) {};
            \node[no] (c) at (8,0) {c};
            \node[no] (z) at (9,0) {};
            \node[no] (d) at (10,0) {d};

            \draw ($(y)$) ellipse ({3.7cm} and {.7cm});
          \end{tikzpicture}
          \bigskip
        \end{subfigure}
        \begin{subfigure}{\textwidth}
          \centering
          \begin{tikzpicture}[
              no/.style={shape=circle, minimum size=1cm},
              scale=1.5, transform shape
            ]
            \node[no] (a) at (4,0) {a};
            \node[no] (x) at (5,0) {};
            \node[no] (b) at (6,0) {b};
            \node[no] (y) at (7,0) {};
            \node[no] (c) at (8,0) {c};
            \node[no] (z) at (9,0) {};
            \node[no] (d) at (10,0) {d};

            \draw ($(b)$) ellipse ({2.8cm} and {.7cm});
            \draw ($(d)$) ellipse ({.7cm} and {.7cm});
          \end{tikzpicture}
        \end{subfigure}
        \caption{Representação dos conjuntos com os elementos $\{a,b,c,d\}$ após a seguinte sequência de operações: \texttt{create\_union(a, b, 2)}, \texttt{create\_union(c, d, 3)}, \texttt{create\_union(b, c, 4)} e \texttt{delete\_union(3)}. Cada linha mostra o estado atual da coleção imediatamente após uma operação.}
        \label{fig:uf-sets}
      \end{figure}

      Na sua versão retroativa, implementamos as seguintes operações:

      \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
          \item[$\bullet$] \textbf{\texttt{create\_union(a, b, t)}}: adiciona a união dos conjuntos que contém $a$ e $b$ no instante de tempo $t$
          \item[$\bullet$] \textbf{\texttt{same\_set(a, b, t)}}: consulta se dois elementos pertenciam ao mesmo conjunto no instante $t$
          \item[$\bullet$] \textbf{\texttt{delete\_union(t)}}: desfaz a união realizada em $t$
        \end{itemize}
      \end{shaded}

      \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      \begin{shaded}
        \textbf{Ideia:} Fazer com que os elementos dos conjuntos sejam vértices na floresta mantida por uma link-cut tree, onde cada aresta representa uma operação de \texttt{union}. Assim, uma chamada \texttt{create\_union(a, b, 3)} cria uma aresta de valor $3$ entre os vértices $a$ e $b$. Da mesma forma, uma chamada \texttt{delete\_union(t)} simplesmente exclui a aresta criada no instante $t$. Para conferir se dois elementos $a$ e $b$, no instante de tempo $t$, estão em um mesmo conjunto, basta conferir se eles estão em uma mesma árvore e se o valor da maior aresta no caminho entre eles é menor ou igual a $t$, o que significa que todas as uniões já foram realizadas no instante consultado.
      \end{shaded}

    \end{block}




    % ----------------------------------------------------------------------------------------
    % TERCEIRA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol

    \begin{block}{Floresta geradora mínima retroativa}

      Como passo inicial temos que introduzir a \textbf{floresta geradora mínima incremental}, uma estrutura que utiliza as link-cut trees para fornecer uma maneira eficiente de consulta acerca da floresta geradora mínima de um grafo que está sempre crescendo, isto é, que está sofrendo a inserção de novas arestas.

      \begin{figure}
        \centering
        \captionsetup{justification=centering}
        \begin{equation*}
          \overbracket{
            \overbracket{
              \overbracket{
                \overbracket{
                  \overbracket{
                    \bolinha{\,0\,}
                  }^{F_0}
                  \bolinha{\,1\,}
                  \bolinha{\,2\,}
                }^{F_1}
                \bolinha{\,3\,}
                \bolinha{\,4\,}
              }^{F_2}
              \bolinha{\,5\,}
              \bolinha{\,6\,}
            }^{F_3}
            \bolinha{\,7\,}
            \bolinha{\,8\,}
          }^{F_4}
        \end{equation*}
        \caption{Representação da lista de $8$ arestas inseridas. Neste caso, cada bloco tem tamanho $2$. Assim, por exemplo, a estrutura $F_3$ contém todas as arestas adicionadas desde o instante $1$ até o instante $6$.}
        \label{fig:sqrt-decomp-blocks-m16}
      \end{figure}

      A \textbf{floresta geradora mínima retroativa} tem a seguinte interface:
      \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
          \item[$\bullet$] \textbf{\texttt{add\_edge(u, v, w, t)}}: adiciona no grafo, no instante $t$, uma aresta com pontas $u$ e $v$ e peso $w$
          \item[$\bullet$] \textbf{\texttt{get\_msf(t)}}: retorna a lista com todas as arestas que compõem uma floresta maximal de peso mínimo do grafo no instante $t$
          \item[$\bullet$] \textbf{\texttt{get\_msf\_weight(t)}}: retorna o custo de uma floresta maximal de peso mínimo no instante $t$
        \end{itemize}
      \end{shaded}

      \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      \begin{shaded}
        \textbf{Ideia:} Organizar cada operação retroativa de inserção numa lista ordenada pelo instante de tempo em que a aresta foi inserida. Em seguida, utilizar a técnica de \textbf{square-root decomposition} para dividir essa lista em $\sqrt{m}$ blocos, onde $m$ é o número total de operações na lista. Essa divisão --- ou como chamamos, reconstrução --- vai sendo refeita conforme novas operações de inserção vão sendo adicionadas, a fim de manter o tamanho dos blocos aproximadamente constante. Por último, é necessário distribuir as operações de cada bloco em diferentes florestas geradoras mínimas incrementais, fazendo com que uma consulta acerca do instante de tempo $t$ possa ser realizada de maneira eficiente por uma estrutura que contenha um grafo com um estado próximo ao instante $t$.
      \end{shaded}

      Por último, além da ideia inicial  para a floresta geradora mínima retroativa, foi necessário adaptar a ideia apresentada por  para transformar estruturas parcialmente retroativas em estruturas totalmente retroativas. Em particular, realizamos uma melhoria na etapa de reconstrução da estrutura, permitindo que ela seja realizada em tempo $\Oh(m \log n)$, onde $n$ é o número de vértices na floresta. Adicionalmente, escrevemos um artigo descrevendo essa melhoria, visando a sua publicação em algum veículo da área teórica de ciência da computação.

    \end{block}

    \begin{block}{Informações e contato}
      Para mais informações, acesse a página do trabalho: \textcolor{jblue}{{\url{https://linux.ime.usp.br/~cjinshian/}}}

      \medskip
      Endereço para contato: \\ \textcolor{jblue}{{\url{cjinshian77@usp.br}}}
    \end{block}

    \begin{block}{Referências}
      \bibliography{bibliografia.bib}
    \end{block}


  \end{columns}
\end{frame}
\end{document}