% Poster get from https://github.com/victorsenam/tcc/blob/master/poster/main.tex

\documentclass[final, brazilian]{beamer}
\usepackage[size=a1,orientation=portrait,scale=1.3]{beamerposter}
\graphicspath{{figuras/}}  

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{framed,graphicx,xcolor} % for shaded box
\usepackage{mathtools}%
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,positioning,shadows,trees,patterns}

\usepackage[shortlabels]{enumitem}
\usepackage[numbers]{natbib}
\bibliographystyle{plainnat}
  \def\bibfont{\small}

\sloppy

%----------------------------------------------------------------------------------------
%	SHORTCUTS
%----------------------------------------------------------------------------------------
\newcommand{\B}[1]{\mathbb{#1}}
\newcommand{\Cl}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\sse}{\Leftrightarrow}
\newcommand{\so}{\Rightarrow}
\newcommand{\se}{\Leftarrow}
\newcommand{\rec}{\leftarrow}

\newcommand{\tdots}{\,.\,.\,}

%----------------------------------------------------------------------------------------
%	BEAMER STYLE
%----------------------------------------------------------------------------------------

\usetheme{poster}
\setbeamercolor{block title}{fg=dblue,bg=white}
\setbeamercolor{block body}{fg=black,bg=white}
\setbeamercolor{block alerted title}{fg=dblue,bg=gray!50}
\setbeamercolor{block alerted body}{fg=black,bg=gray!20}
\setbeamercolor{block prob}{fg=black,bg=white}
\setbeamertemplate{caption}[numbered]

%----------------------------------------------------------------------------------------
%	CUSTOM STYLING
%----------------------------------------------------------------------------------------

\newenvironment<>{prob}{
    \begin{beamercolorbox}[sep=1ex,center,dp={1ex}]{block prob}
    \textcolor{dblue}{\textbf{Problema:}}\itshape
}{\end{beamercolorbox}}

\newcommand\halfcol{\column{.46\textwidth}}
\newcommand\onethirdcol{\column{.31\textwidth}}

\newcommand{\Oh}{\mathrm{O}}

% ?????????
\usepackage{subcaption}

\newcommand*\bolinha[1]{\; \tikz[inner sep=.25ex]\node[circle,draw]{#1}; \;}

%----------------------------------------------------------------------------------------
%	POSTER
%----------------------------------------------------------------------------------------

\title{Florestas geradoras maximais de custo
mínimo em grafos dinâmicos}
\author{Chung Jin Shian \hspace{200pt} Orientadora: Cristina Gomes Fernandes}
\institute{\vspace{10pt}Departamento de Ciência da Computação,
Instituto de Matemática e Estatística, Universidade de São Paulo}


\begin{document}
\begin{frame}[fragile]\centering
  \vspace{-40pt}
  \begin{columns}[T]

    % ----------------------------------------------------------------------------------------
    % PRIMEIRA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol
    \begin{alertblock}{Resumo}
      Grafos dinâmicos permitem modelar problemas em que o conjunto de arestas do grafo sofre alterações ao longo do tempo. Um dos problemas fundamentais nesse contexto é a manutenção de uma árvore geradora de custo mínimo do grafo dinâmico. Estudamos vários algoritmos propostos por Holm, de Lichtenberg e Thorup \cite{jacob_holm} para variantes desse problema. O foco foi no algoritmo para manter uma floresta maximal de custo mínimo (MSF) decremental, que dá suporte eficiente à remoção de arestas. Esse algoritmo foi implementado e testado em grafos com centenas de milhares de vértices. 
    \end{alertblock}

    \begin{block}{Conexidade em grafos dinâmicos}
     O problema da conexidade em grafos dinâmicos visa uma implementação eficiente da biblioteca abaixo:
      
            \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
            \item[$\bullet$] \texttt{\textbf{grafoDinâmico($n$)}}: contrói e devolve um grafo dinâmico com $n$ vértices e sem arestas;
            \item[$\bullet$] \texttt{\textbf{conectadosGD($G$, $u$, $v$)}}: devolve verdadeiro se os vértices $u$ e $v$ estão na mesma componente de $G$ e falso caso contrário;
            \item[$\bullet$] \texttt{\textbf{adicioneGD($G$, $u$, $v$)}}: adiciona a aresta $uv$ no grafo $G$;
            \item[$\bullet$] \texttt{\textbf{removaGD($G$, $u$, $v$)}}: remove a aresta $uv$ do grafo $G$.
        \end{itemize} 
      \end{shaded}

      \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      \begin{shaded}
        \textbf{Ideia:} Fatiar o grafo $G$ em níveis. Cada aresta do grafo possui um nível entre 1 e $\left\lceil \lg n \right\rceil$, onde $n$
        é o número de vértices do grafo $G$. Uma aresta, ao ser inserida em $G$, começa com o nível $\left\lceil \lg n \right\rceil$ e, durante o algoritmo, seu nível vai sendo decrementado. Seja $G_i$ = $G[X]$ onde $X$ é o conjunto das arestas do grafo $G$ de nível menor ou igual a $i$. Para cada nível $i$, o algoritmo mantém uma floresta maximal $F_i$ de $G_i$. Além disso, ele mantém também um grafo $R_i$ em forma de listas de adjacências, que guardam as arestas de nível $i$ que não estejam em $F_i$, chamadas de arestas reserva.
      \end{shaded}

      Cada floresta $F_i$ é mantida em uma estrutura de dados específica para florestas dinâmicas, baseada em Euler tour trees. Cada componente de $F_i$ é armazenada como uma Euler tour tree. Em nossa implementação, Euler tour trees são implementadas como splay trees.
      

      \begin{figure}[H]
          \centering

          % Elemento 1: Grafo original e Dígrafo Euleriano (do primeiro figure)
          \begin{minipage}{0.7\textwidth} % Usa aproximadamente 70% da largura do texto
              \centering
              \begin{tikzpicture}[thick, node distance=2cm,
                vtx/.style={draw, circle, minimum size=10mm, inner sep=0pt}]

              % ---------- Left: original graph ----------
              \node[vtx] (a) at (0,0) {$a$};
              \node[vtx] (b) at (1.5,1.5) {$b$};
              \node[vtx] (c) at (3,0) {$c$};
              \node[vtx] (d) at (1.5,-1.5) {$d$};
              \node[vtx] (e) at (-1.5,-1.5) {$e$};

              % Graph edges
              \draw (a) -- (b);
              \draw (c) -- (d);
              \draw (d) -- (a);
              \draw (a) -- (e);
              
              % Adiciona uma label ou descrição para o primeiro gráfico
              \node at (-1, 1) {$T$};

              % ---------- Right: Euler-tour representation ----------
              \begin{scope}[xshift=8cm]
                \node[vtx] (a1) at (0,0) {$a$};
                \node[vtx] (b1) at (1.5, 1.5) {$b$};
                \node[vtx] (c1) at (3,0) {$c$};
                \node[vtx] (d1) at (1.5,-1.5) {$d$};
                \node[vtx] (e1) at (-1.5,-1.5) {$e$};

                % Bidirectional arcs
                \draw[->] (a1) to[bend left=20] (b1);
                \draw[->] (b1) to[bend left=20] (a1);

                \draw[->] (c1) to[bend left=20] (d1);
                \draw[->] (d1) to[bend left=20] (c1);

                \draw[->] (d1) to[bend left=20] (a1);
                \draw[->] (a1) to[bend left=20] (d1);

                \draw[->] (a1) to[bend left=20] (e1);
                \draw[->] (e1) to[bend left=20] (a1);

                \draw[->] (a1) edge[loop above] ();
                \draw[->] (b1) edge[loop above] ();
                \draw[->] (c1) edge[loop right] ();
                \draw[->] (d1) edge[loop below] ();
                \draw[->] (e1) edge[loop left] ();
                
                % Adiciona uma label ou descrição para o segundo gráfico
                \node at (1.5, 2.5) {};

              \end{scope}
              
              \draw[->, blue, very thick] ([xshift=1cm]b.east) 
                  to[out=30, in=150] ([xshift=6cm]b.west); % Start from 'b.east', 
              \node[blue, font=\small] at (5.5, 2.6) {digrafo Euleriano}; % Text above the arrow path
                
              \draw[->, blue, very thick] ([yshift=-1cm]d1.south) 
                  to[out=-20, in=20] ([yshift=-5cm]d1.south); % Start from 'b.east', 
                \node[blue, font=\small, fill=white, inner sep=2pt] at (10.5, -4.7) {trilha Euleriana};

                

              \end{tikzpicture}
          \end{minipage}

          \vspace{-2cm}
          \begin{minipage}{\textwidth} 
              \centering
              \begin{tikzpicture}
                    [node/.style={circle,draw,minimum size=10mm, thick},
                    edge/.style={thick, black},
                    reserve/.style={red, thick},
                    removed/.style={black, thick, dashed}, 
                    inner sep=0pt]

                    % Aumentando a distância horizontal (xshift) e vertical (yshift)
                    % para melhor visualização ao combinar com o primeiro gráfico, 
                    % e ajustando as coordenadas para centralizar o nó raiz.
                    
                    \node[node] (ad) at (0, 0) {$ad$};
                    \node[node] (ab) at (-4.5, -1.5) {$ab$};
                    \node[node] (cd) at (4.5, -1.5) {$cd$};
                    \node[node] (dc) at (3, -3) {$dc$};
                    \node[node] (dd) at (1.5, -4.5) {$dd$};
                    \node[node] (cc) at (4.5, -4.5) {$cc$};
                    \node[node] (da) at (6, -3) {$da$};
                    \node[node] (ae) at (7.5, -4.5) {$ae$};
                    
                    
                    \node[node] (ea) at (-6, -3) {$ea$};
                    \node[node] (ee) at (-7.5, -4.5) {$ee$};
                    \node[node] (aa) at (-4.5, -4.5) {$aa$};


                    \node[node] (bb) at (-3, -3) {$bb$};
                    \node[node] (ba) at (-1.5, -4.5) {$ba$};

                    

                    % tree edges (normal black edges)
                    \draw[edge] (ad) -- (ab) node[midway, below] {};
                    \draw[edge] (ad) -- (cd) node[midway, below] {};
                    \draw[edge] (cd) -- (dc) node[midway, below] {};
                    \draw[edge] (cd) -- (da) node[midway, below] {};
                    \draw[edge] (bb) -- (ba) node[midway, below] {};
                    \draw[edge] (ea) -- (ee) node[midway, below] {};
                    \draw[edge] (ea) -- (aa) node[midway, below] {};
                    \draw[edge] (dc) -- (dd) node[midway, below] {};
                    \draw[edge] (dc) -- (cc) node[midway, below] {};
                    \draw[edge] (da) -- (ae) node[midway, below] {};

                    \draw[edge] (ab) -- (ea) node[midway, below] {};
                    \draw[edge] (ab) -- (bb) node[midway, below] {};

                    \node at (-4, 0.9) {Euler tour};
                    \node at (-4, 0) {tree de $T$};
              \end{tikzpicture}
              % Adiciona uma label ou descrição para o terceiro gráfico
          \end{minipage}

          \label{fig:arvore-euler-tour-combinada}
      \end{figure}
 
O algoritmo mantém as seguintes invariantes:

       \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      \begin{shaded}
\begin{itemize}
    \item[$\bullet$] \label{invariant1} $F_i$ é floresta maximal de $G_i$ para $1 \leq i \leq  \left\lceil \lg n \right\rceil$;
    
    \item[$\bullet$] \label{invariant2} $F_i \subseteq F_{i+1}$ para $1 \leq i \leq \left\lceil \lg n \right\rceil - 1$;
    
    \item[$\bullet$] \label{invariant3} Cada componente $F_i$ tem no máximo $2^i$ vértices.
\end{itemize}
\end{shaded}
    \end{block}

    
    % ----------------------------------------------------------------------------------------
    % SEGUNDA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol
    
    \begin{block}

    Nos pseudocódigos abaixo, esboçamos a remoção de uma aresta do grafo. As Euler tour trees carregam informação extra para que a implementação das linhas $6$, $7$, $10$ e $11$ do método \texttt{substituaAresta} seja eficiente. 
    
    \begin{figure}[htb]
    \centering
    % The file name here does NOT include the 'extras/' path 
    % because $of the \graphicspath command above.
    \includegraphics[width=1\linewidth]{removaGD.png}
    
    \label{prog:removeGD_image} % Use a meaningful label for referencing
\end{figure}
      
    \begin{figure}[htb]
    \centering
    % The file name here does NOT include the 'extras/' path 
    % because of the \graphicspath command above.
    \includegraphics[width=1\linewidth]{substituaAresta.png}
    
    \label{prog:replaceGD_image} % Use a meaningful label for referencing
\end{figure}

\begin{figure}[htb]
    \centering
    % The file name here does NOT include the 'extras/' path 
    % because of the \graphicspath command above.
    \includegraphics[width=1\linewidth]{testeSubstituta.png}
    
    \label{prog:testSubstitute_image} % Use a meaningful label for referencing
\end{figure}
      
    Na nossa implementação, que utiliza splay trees, alguns dos métodos têm  consumo amortizado por operação.

    \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
            \item[$\bullet$] \texttt{\textbf{grafoDinâmico($n$)}}: $\Oh(n \lg n)$;
            \item[$\bullet$] \texttt{\textbf{conectadosGD($G$, $u$, $v$)}}: amortizado $\Oh(\lg n)$;
            \item[$\bullet$] \texttt{\textbf{adicioneGD($G$, $u$, $v$)}}: amortizado $\Oh(\lg n)$;
            \item[$\bullet$] \texttt{\textbf{removaGD($G$, $u$, $v$)}}: amortizado $\Oh(\lg^2 n)$.
        \end{itemize} 
      \end{shaded}

    \end{block}































    % ----------------------------------------------------------------------------------------
    % TERCEIRA COLUNA
    % ----------------------------------------------------------------------------------------
    \onethirdcol

    \begin{block}{MSF decremental}
      
     O problema da manutenção de uma MSF decremental do grafo visa uma implementação eficiente dos métodos da biblioteca abaixo:
      
      \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
          \item[$\bullet$] \texttt{\textbf{MSFDecremental($n$, $E$)}}: constrói e devolve o grafo ponderado $G$ com $n$ vértices e as arestas ponderadas dadas no conjunto $E$;
          \item[$\bullet$] \texttt{\textbf{consultePesoMSF($G$)}}: devolve o peso de uma MSF do grafo ponderado $G$;
          \item[$\bullet$] \texttt{\textbf{removaMSF($G$, $u$, $v$)}}: remove a aresta $uv$ do grafo ponderado $G$.
        \end{itemize}
      \end{shaded}

      \definecolor{shadecolor}{rgb}{0.74, 0.83, 0.9} % pale blue
      \begin{shaded}
        \textbf{Ideia:} remover uma aresta de nível $i$ da floresta $F_i$, quebra uma componente desta em duas, $T_u$ e $T_v$. Precisamos buscar uma aresta substituta com o menor peso que ligue $T_u$ a $T_v$. Em vez de usar listas de adjacências para armazenar os vizinhos de cada vértice, usa-se um min-heap, onde a chave para um vizinho $v$ será o peso da aresta $uv$. Dessa forma, basta procurar por uma aresta em $R_i$ que incide em $T_u$ e que tenha o menor peso que conecte $T_u$ e $T_v$, para podermos manter o peso mínimo de uma MSF do grafo ao longo das remoções de arestas. 
      \end{shaded}

      Na figura abaixo, veja que as linhas $11$ e $14$ passamos a procurar a aresta de peso mínimo em $R_i$ incidente a $T_u$.

      \begin{figure}[htb]
          \centering

          \includegraphics[width=1\linewidth]{substituaArestaMSF.png}
          
          \label{prog:replaceGDMSF_image} 
      \end{figure}

    Abaixo está o consumo de tempo da nossa implementação:

    \definecolor{shadecolor}{rgb}{0.93, 0.80, 0.82} % pale pink
      \begin{shaded}
        \begin{itemize}
            \item[$\bullet$] \texttt{\textbf{grafoDinâmico($n$)}}: $\Oh(n \lg m)$;
            \item[$\bullet$] \texttt{\textbf{consultePesoMSF($G$)}}: $\Oh(1)$;
            \item[$\bullet$]  \texttt{\textbf{removaGD($G$, $u$, $v$)}}: amortizado $\Oh(\lg^2 n)$.
        \end{itemize} 
      \end{shaded}

      Testamos a remoção das arestas das um grafo $G$ com 300.000 vértices e 300.000 arestas, realizando uma comparação da performance do algoritmo de Kruskal e da MSF decremental que implementamos. 


      <INSERIR GRÁFICO DA COMPARAÇÃO DA PERFORMANCE>

    \end{block}

    \begin{block}{Informações e contato}
      Para mais informações, acesse a página do trabalho: \textcolor{jblue}{{\url{https://linux.ime.usp.br/~cjinshian/}}}

      \medskip
      Endereço para contato: \textcolor{jblue}{{\url{cjinshian77@usp.br}}}
    \end{block}

    \begin{block}{Referências}
      \scriptsize{
      \begin{thebibliography}{30}

          \bibitem{jacob_holm}
          Holm, J., de Lichtenberg, K., Thorup, M.,
          ``\textbf{Poly-Logarithmic Deterministic Fully-Dynamic Algorithms for Connectivity, Minimum Spanning Tree, 2-Edge, and Biconnectivity},''
          \textit{Journal of the ACM}, 48(4): 723--760, 2001.

      \end{thebibliography}
      }


    \end{block}


  \end{columns}
\end{frame}
\end{document}