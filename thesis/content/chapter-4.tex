\chapter{Conclusões}
\label{chapter:conclusions}

Neste trabalho, estudamos, implementamos e apresentamos um algoritmo para a MSF decremental. Esse algoritmo é uma adaptação do algoritmo para conexidade em grafos dinâmicos. Essencialmente, a adaptação consiste em trocar a estrutura de dados usada para armazenar as arestas reserva de listas de adjacências para min-heaps.

Estudamos também o algoritmo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm} para o problema da MSF dinâmica, no qual se quer dar suporte eficiente também a inserções de arestas a qualquer momento. Esse algoritmo também é uma adaptação do algoritmo para conexidade em grafos dinâmicos, mas é uma adaptação mais extensa e complexa, que utiliza uma implementação adaptada do algoritmo para MSF decremental que implementamos.

A adaptação agora troca a estrutura de dados usada para armazenar as florestas dinâmicas. Em vez de Euler tour trees, esse algoritmo usa as chamadas \textbf{top trees}, que são versões de uma árvore introduzida por Alstrup et al~\cite{alstrup_top_trees_arxiv} e denominada de \textbf{topological trees}.

Inicialmente será descrito resumidamente o papel principal das top trees no algoritmo. Nas Euler tour trees, um caminho não corresponde a um segmento contínuo ao longo do percurso da Euler tour tree. Isso dificulta a manutenção eficiente de informações sobre caminhos na árvore, como, por exemplo, a aresta com o peso máximo no caminho entre dois vértices dados.
Por causa disso, os autores do artigo sugeriram o uso de top trees para armazenar e retornar dados sobre qualquer caminho entre dois vértices numa árvore.

Top trees são árvores binárias que suportam adição e remoção de arestas. A construção delas se baseia em uma sequência de \texttt{merges} e \texttt{splits}, que acabam destruindo e reconstruindo nós e arestas da árvore. Conforme Alstrup et al~\cite{alstrup_top_trees_arxiv}, para uma floresta dinâmica de $n$ vértices podemos manter top trees de altura $\Oh(\lg n)$ suportando qualquer operação em uma sequência de $\Oh(\lg n)$ \texttt{merges} e \texttt{splits}. Podemos, então, definir uma operação que retorna o peso máximo de um caminho entre dois vértices em tempo $\Oh(\lg n)$, que será fundamental na operação de inserção de arestas do algoritmo para MSF dinâmica.  

Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propuseram um algoritmo para MSF dinâmica que mantém uma MSF que suporta adições e remoções de arestas em tempo amortizado $\Oh(\lg^4 n)$ por operação. A ideia deste algoritmo é manter uma MSF decremental $F$ de um grafo $G$ de $n$ vértices e $m$ arestas, como também um conjunto $\mathcal{G} = \{G_0, \ldots, G_L\}$, $L = \left\lceil \lg m \right\rceil$, de subgrafos de $G$, de modo que para cada $G_i$ manteremos uma MSF decremental $F_i$.

As arestas de $F$ são chamadas de \textbf{arestas da floresta globais} e as arestas de $R = G \textbackslash
 F$ são chamadas de \textbf{arestas reserva globais}, onde $R$ corresponde à lista de arestas reserva retornadas pelas estruturas decrementais de $\mathcal{G}$. É nesta lista que iremos procurar, se houver, uma aresta substituta de menor peso para reconectar as componentes separadas de $F$ quando removemos alguma aresta da floresta global.

Similarmente, as arestas de $F_i$ são chamadas de \textbf{arestas da floresta locais} e as arestas de $R_i = G_i \textbackslash
 F_i$ de \textbf{arestas reserva locais}. Além disso, todas as arestas de $G$ estarão em alguma $G_i$, de modo que $F \subseteq \bigcup_i F_i$.

Para inserir uma aresta $uv$, temos dois casos a considerar:

\begin{itemize}
    \item se $u$ e $v$ não estão conectados, então basta inserir a aresta $uv$ em $F$;
    \item caso contrário, temos dois casos:
    \begin{itemize}
        \item se o caminho entre $u$ e $v$ conter uma aresta $w$ cujo peso é maior que o de $uv$, então substituímos $w$ por $uv$, e atualizamos $\mathcal{G}$ com $w$;
        \item caso contrário, atualizamos $\mathcal{G}$ com $uv$.
    \end{itemize}
\end{itemize}

Já para remover uma aresta $uv$, primeiramente removemos todas as ocorrências desta aresta em $G_i$. Se $uv$ for uma aresta de $F$, removemo-la de $F$ e
verificamos se em $R$ há arestas que reconectem as componentes separadas de $F$. Se houver, escolhemos a de menor peso dentre elas. Finalmente, independentemente se $uv$ é uma aresta da floresta global ou aresta reserva global, atualizamos $\mathcal{G}$ com $R$.

Quando falamos em atualizar $\mathcal{G}$ com um conjunto $E$ de arestas, queremos encontrar o menor $j$ tal que $|(E \cup \bigcup_{h \leq j} R_h) \textbackslash F| \leq 2^j$. Em seguida, definimos
$$
G_j := F \cup E \cup \bigcup_{h \leq j} R_h 
$$
inicializando $G_j$ como uma nova MSF decremental. Por fim, definimos $G_h := \emptyset$ para todo $h < j$.

Na verdade, a atualização de $\mathcal{G}$ ocorre com a adição de uma floresta $F$ de modo implícito, que no caso é a $F'$. O artigo explica em detalhes sobre como a $F'$ é construída, e para isso ele se baseia fortemente na estrutura das top trees para podermos implementar este algoritmo para MSF dinâmica mais eficientemente, tanto de espaço quanto de consumo de tempo. No final da Seção~5 do artigo, é mencionado que a implementação deste algoritmo consome espaço $O(m \lg n)$.

Até o momento, fica claro que há uma certa cadeia de dependências entre os algoritmos que estudamos e implementamos. Dessa forma, seria interessante apresentar os detalhes de como implementar a biblioteca deste algoritmo para MSF dinâmica. Mas, para isso, precisaríamos modificar a implementação da biblioteca da conexidade em florestas dinâmicas, que passaria a manter top trees no lugar de Euler tour trees. Como a nossa implementação da biblioteca de Euler tour trees possui um consumo de tempo diferente da implementação de top trees apresentada em Holm, de Lichtenberg e Thorup~\cite{jacob_holm}, a biblioteca que implementamos do algoritmo de conexidade em grafos dinâmicos teria a sua complexidade de tempo alterada, visto que este passaria a manter componentes destas florestas dinâmicas ajustadas. 

Além disso, ajustes na biblioteca do algoritmo de conexidade em grafos dinâmicos alteraria, por sua vez, o consumo de tempo da biblioteca que implementamos do algoritmo para MSF decremental. É após todos estes ajustes que, finalmente, poderíamos implementar o algoritmo para a MSF dinâmica proposta por Holm, de Lichtenberg e Thorup~\cite{jacob_holm}.

Em suma, dada a complexidade de se realizar estes ajustes nos algoritmos já implementados, optamos por não descrever uma biblioteca deste algoritmo para MSF dinâmica e implementá-la.
