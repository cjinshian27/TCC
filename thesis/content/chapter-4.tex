\chapter{Testes experimentais}
\label{chapter:experiments}

Nesta seção, apresentaremos alguns testes de comparação de performance entre os algoritmos de Kruskal e da MSF decremental. Os experimentos foram realizados em um computador pessoal com as seguintes configurações: 

\begin{itemize}
    \item Sistema operacional Ubuntu 24.04.3 LTS (kernel 6.8.0-49-generic);
    \item Processador Intel Core i5-8265U (4 núcleos, 8 threads), arquitetura x86\_64;
    \item Memória RAM de 7,6 GB; 
    \item GPU Intel UHD Graphics 620.
\end{itemize}

Para calcular a duração de tempo de uma operação em milissegundos, utilizamos a biblioteca \texttt{chrono} da linguagem \textit{C++}. Além disso, o experimento não considera o tempo pra inicializar um grafo com $n$ vértices e $m$ arestas, apenas a remoção das arestas e a consulta do peso da MST após a remoção delas. 

Foi construído um gerador de grafos aleatórios, seguindo um modelo $G(n, p)$, em que $n$ é o número de vértices do grafo $G$ e $p$ a probabilidade da existência de cada aresta. Considera-se como limiar crítico o valor de $p = \frac{\lg n}{n} $. Assim, temos que o número esperado de arestas em um grafo $G(n, p)$ é dado por $\frac{n(n-1)}{2} \cdot p$. Ademais, a cada aresta é atribuído um peso inteiro no intervalo de $1$ a $n$.

Cada arquivo gerado de teste possui a primeira linha com os valores $n$ e $m$, seguida de $m$ linhas da forma $u$ $v$ $w$, onde $w$ é o peso da aresta $uv$. Em seguida, temos outras $m$ linhas da forma $u$ $v$, que representam uma permutação aleatória de arestas a serem removidas. No experimento, entretanto, removemos somente as primeiras 25.600 arestas da permutação, o que foi suficiente para demonstrar a eficiência do algoritmo da MSF decremental.

Cada grafo gerado possui $n = 20.000$ vértices, o que dá um número esperado de arestas de $142.000$. Nos nossos experimentos, geramos seis grafos $G_i$, $0 \leq i \leq 5$, com cinco permutações aleatórias distintas de arestas para cada.   
Primeiramente, testamos o grafo $G_0$ e a remoção de $25.600$ arestas para todas as cinco permutações, mostrando o peso da MST após cada lote de arestas removido e o tempo em milissegundos gasto pelos dois algoritmos para remover cada lote. Depois, calculamos a média dos cinco testes realizados. Por fim, realizamos os mesmos experimentos de $G_0$  em outros cinco grafos, usando a primeira permutação de arestas gerada. Os resultados foram exibidos em tabela e gráfico feitos na linguagem \textit{Python 3}.

Para cada grafo, realizamos a remoção de arestas em lotes sucessivos. Após cada lote de remoções, imprimimos a MST correspondente ao estado atual do grafo e, em seguida, dobramos o tamanho do lote. Dessa forma, removemos $100, 200, 400, \ldots, 25.600$ arestas, registrando tanto o tempo acumulado das remoções quanto o peso da MST após cada etapa.

\subsection{Algoritmo de Kruskal}

O algoritmo de Kruskal foi implementado de uma forma que permita remoção de arestas. Utilizamos Union-Find como a parte central do algoritmo. Na inicialização do construtor, ordenamos um vetor de $m$ arestas em ordem crescente de peso, usando o método \texttt{sort} da linguagem \textit{C++}, que consome tempo esperado $O(m \lg m)$. Em seguida, acionamos o método \texttt{union} para adicionar as arestas, uma a uma, em ordem crescente de peso.

Quando removemos uma aresta $uv$, precisamos reordenar as arestas restantes. Para isso, usamos o algoritmo de ordenação \textit{insertion sort}, visto que ele consome tempo $O(m)$ para ordenar um vetor de arestas quase ordenado. No nosso caso, como a $uv$ é trocada pela última aresta do vetor e removida, obtemos um vetor quase ordenado. Isso garante a complexidade de tempo $O(m)$ quando ordenamos as arestas remanescentes.

\subsection{Grafo $G_0$}

