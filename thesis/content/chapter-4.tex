\chapter{Testes experimentais}
\label{chapter:experiments}

Neste capítulo, apresentaremos alguns testes de comparação de performance entre o algoritmo descrito no Capítulo~\ref{chapter:msf-decremental-chapter} e uma versão do algoritmo de Kruskal adaptado para o problema da MSF decremental. Os experimentos foram realizados em um computador pessoal com as seguintes configurações: 

\begin{itemize}
    \item Sistema operacional Ubuntu 24.04.3 LTS (kernel 6.8.0-49-generic);
    \item Processador Intel Core i5-8265U (4 núcleos, 8 threads), arquitetura x86\_64;
    \item Memória RAM de 7,6 GB; 
    \item GPU Intel UHD Graphics 620.
\end{itemize}

Para calcular a duração de tempo de uma operação em milissegundos, utilizamos a biblioteca \texttt{chrono} da linguagem \textit{C++}. Além disso, o experimento não considera o tempo para inicializar um grafo com $n$ vértices e $m$ arestas. Considera apenas o tempo para as remoções das arestas e para as consultas ao peso de uma MST. 

Foi implementado um gerador de grafos aleatórios, seguindo o modelo $G(n, p)$, em que $n$ é o número de vértices e $p$ a probabilidade da existência de cada aresta. É sabido que, no modelo $G(n, p)$ de Erdős-Rényi, o limiar para conexidade é $p = \frac{\ln n}{n}$. Nos nossos experimentos, usamos o valor $p = \frac{\lg n}{n} > \frac{\ln n}{n}$, $n > 1$. Assim, temos que o número esperado de arestas nos grafos gerados é dado por $\frac{n(n-1)\lg n}{2n}$. Ademais, a cada aresta é atribuído um peso inteiro no intervalo de $1$ a $n$.

Cada arquivo de teste gerado possui a primeira linha com os valores $n$ e $m$, seguida de $m$ linhas da forma $u$ $v$ $w$, onde $w$ é o peso da aresta $uv$. Em seguida, temos outras $k$ linhas da forma $u$ $v$, que representam uma lista aleatória das arestas a serem removidas. Nos experimentos, cada grafo gerado possui $n = 20.000$ vértices, o que dá um número esperado de arestas de $142.000$, e removemos $k = 25.600$ arestas, o que foi suficiente para demonstrar a eficiência do algoritmo da MSF decremental.

Nos nossos experimentos, geramos seis grafos $G_i$, $0 \leq i \leq 5$, com cinco listas aleatórias distintas de arestas para cada.   
Inicialmente, avaliamos o grafo $G_0$ considerando a remoção de $25.600$ arestas em cinco listas distintas. Para cada lista, registramos o peso de uma MST após a remoção de uma certa quantidade de arestas e o tempo de execução, em milissegundos, dos dois algoritmos. Depois, calculamos a média dos cinco testes realizados. Por fim, realizamos os mesmos experimentos de $G_0$  em outros cinco grafos, usando somente a primeira lista de arestas gerada para cada grafo. Os resultados foram apresentados em tabelas e gráficos gerados por programas escritos em \textit{Python~3}.

Para cada grafo, realizamos a remoção de arestas em lotes sucessivos. Após cada lote de remoções, imprimimos o peso de uma MST correspondente ao estado atual do grafo e, em seguida, dobramos o tamanho do lote. Assim, removemos $100, 200, 400, \ldots, 25.600$ arestas, registrando o tempo acumulado das remoções e o peso de uma MST após cada etapa.

\section{Algoritmo de Kruskal}

O algoritmo de Kruskal foi implementado de uma forma que permita remoção de arestas. Utilizamos Union-Find como a parte central do algoritmo. Na inicialização do construtor, ordenamos o vetor de $m$ arestas em ordem crescente de peso, usando o método \texttt{sort} da linguagem \textit{C++}, que consome tempo esperado $O(m \lg m)$. Em seguida, inserimos as arestas no grafo, em ordem crescente de peso.

Quando removemos uma aresta $uv$, precisamos reordenar as arestas restantes. Para isso, basta deslocar as arestas a partir de $uv$ de uma posição para cima no vetor, o que consome tempo $O(m)$.

\section{Grafo $G_0$}
\label{section:graph0}

O grafo $G_0$ gerado tem 142.069 arestas, que é um número próximo do esperado. A seguir, mostraremos os resultados das remoções de algumas listas de arestas, visto que o comportamento dos gráficos e valores das tabelas são muito parecidos. É importante ressaltar que, como o algoritmo derivado de Kruskal consome tempo $O(m)$ por remoção de aresta, optamos por fazer uma compressão de valores dos eixos $x$ e $y$ dos gráficos para evitar a sobreposição dos números, preservando ainda a aparência de crescimento linear.


\subsection{Primeira lista de arestas}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_0_permutation_2.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_0$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g0_permutation2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_0_permutation_2.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_0$.}
    \label{fig:graph_g0_permutation2}
\end{figure}

\subsection{Segunda lista de arestas}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_0_permutation_4.png}
    \caption{Desempenho dos dois algoritmos na segunda lista de arestas de $G_0$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g0_permutation4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_0_permutation_4.png}
\caption{Desempenho dos dois algoritmos na segunda lista de arestas de $G_0$.}

    \label{fig:graph_g0_permutation4}
\end{figure}

\subsection{Tempo médio de execução das cinco listas de arestas}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_0_average.png}
\caption{Tempo médio de execução obtido a partir de cinco listas de arestas de $G_0$.}
    \label{fig:table_g0_average}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_0_average.png}
\caption{Comparação do tempo médio de execução dos dois algoritmos ao longo de cinco listas de arestas de $G_0$.}
    \label{fig:graph_g0_average}
\end{figure}

\section{Grafos $G_1$, $G_2$, $G_3$, $G_4$ e $G_5$}

Neste experimento, realizamos os mesmos experimentos de $G_0$, mas usando apenas a primeira lista aleatória de arestas de outros cinco grafos. Isso porque vimos na Seção~\ref{section:graph0} que os resultados entre as diferentes listas aleatórias de um mesmo grafo são bem parecidos. Por isso, focamos no desempenho dos dois algoritmos em grafos aleatórios distintos. O grafo $G_1$ tem $142.589$ arestas; o grafo $G_2$ tem $142.954$ arestas; o grafo $G_3$ tem $142.734$ arestas; o grafo $G_4$ tem $142.402$ arestas; e o grafo $G_5$ tem $143.216$ arestas.

\subsection{Grafo $G_1$}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_1.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_1$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g1_permutation0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_1.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_1$.}
    \label{fig:graph_g1_permutation0}
\end{figure}

\subsection{Grafo $G_2$}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_2.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_2$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g2_permutation0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_2.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_2$.}
    \label{fig:graph_g2_permutation0}
\end{figure}

\subsection{Grafo $G_3$}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_3.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_3$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g3_permutation0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_3.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_3$.}
    \label{fig:graph_g3_permutation0}
\end{figure}


\subsection{Grafo $G_4$}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_4.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_4$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g4_permutation0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_4.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_4$.}
    \label{fig:graph_g4_permutation0}
\end{figure}

\subsection{Grafo $G_5$}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_graph_5.png}
    \caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_5$, exibindo o peso de uma MST após a remoção de cada lote de arestas.}
    \label{fig:table_g5_permutation0}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/graph_5.png}
\caption{Desempenho dos dois algoritmos na primeira lista de arestas de $G_5$.}
    \label{fig:graph_g5_permutation0}
\end{figure}

\subsection{Tempo médio de execução dos cinco grafos}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/performance_table_5_graphs_average.png}
\caption{Tempo médio de execução obtido a partir de cinco grafos.}
    \label{fig:performance_table_5_graphs_average}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=11cm]{./figuras/5_graphs_average.png}
\caption{Comparação do tempo médio de execução dos dois algoritmos considerando cinco grafos distintos.}
    \label{fig:5_graphs_average}
\end{figure}

\section{Conclusão}

A partir dos experimentos realizados, verifica-se que os grafos gerados para os testes apresentam um número de arestas próximo do valor esperado para um grafo do modelo $G(n, p)$, com $p = \frac{\lg n}{n}$. Além disso, os resultados indicam que, nos gráficos de tempo de execução, o algoritmo derivado de Kruskal apresenta um crescimento aproximadamente linear em função do número de arestas removidas, enquanto o algoritmo para MSF decremental exibe um padrão de crescimento compatível com o esperado que é polilogarítmico.

As tabelas de resultados, por outro lado, evidenciam a diferença significativa no tempo de execução entre os dois algoritmos durante o processo de remoção de arestas, diferença esta que já se mostra perceptível mesmo nas primeiras remoções realizadas.

Portanto, observa-se que os experimentos conduzidos sobre diferentes grafos aleatórios com o mesmo número de vértices produzem gráficos e tabelas com comportamentos semelhantes no que tange ao tempo de execução, indicando consistência nos resultados obtidos.

Por fim, seria interessante usar essas implementações para testar os algoritmos em grafos vindos de aplicações reais.
