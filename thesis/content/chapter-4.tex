\chapter{Conclusões}
\label{chapter:conclusions}

Neste capítulo, consideraremos o problema da \textbf{MSF dinâmica}, onde queremos manter uma MSF em um grafo dinâmico. Estudaremos brevemente um algoritmo para MSF dinâmica, proposto por Holm, de Lichtenberg e Thorup~\cite{jacob_holm}. Como este algoritmo não foi implementado em nosso estudo, apresentaremos apenas a ideia por trás dele, de como podemos manter o peso mínimo de uma MSF de um grafo $G$ dando suporte eficiente à adição e remoção de arestas. Inicialmente, será descrito o rapidamente o papel principal das \textbf{top trees} no algoritmo, estruturas de dados que serão usadas na manutenção de uma MSF dinâmica. Estas estruturas estão descritas em mais detalhes na Seção~2 do artigo de Alstrup, Holm, de Lichtenberg e Thorup~\cite{alstrup_top_trees_arxiv}. 

Como vimos nas Euler tour trees, um caminho não corresponde a um segmento contínuo ao longo do percurso da Euler tour tree. Isso dificulta a manutenção eficiente de informações sobre caminhos na árvore, como, por exemplo, a aresta com o peso máximo no caminho entre dois vértices dados.
Dessa forma, os autores do artigo sugeriram o uso de top trees para armazenar e retornar dados sobre qualquer caminho entre dois vértices numa árvore.

Top trees são árvores binárias que suportam adição e remoção de arestas. A construção delas se baseia em uma sequência de \texttt{merges} e \texttt{splits}, que acabam destruindo e reconstruindo nós e arestas da árvore. Conforme Alstrup et al~\cite{alstrup_top_trees_arxiv}, para uma floresta dinâmica de $n$ vértices podemos manter top trees de altura $\Oh(\lg n)$ suportando qualquer operação em uma sequência de $\Oh(\lg n)$ \texttt{merges} e \texttt{splits}. Podemos, então, definir uma operação que retorna o peso máximo de um caminho entre dois vértices em tempo $\Oh(\lg n)$, que será fundamental na operação de inserção de arestas do algoritmo para MSF dinâmica.  

Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propuseram um algoritmo para MSF dinâmica que mantém uma MSF que suporta adições e remoções de arestas em tempo amortizado $\Oh(\lg^4 n)$ por operação. A ideia deste algoritmo é manter uma MSF $F$ de $G$, um grafo de $n$ vértices e $m$ arestas, como também um conjunto $\mathcal{G} = \{G_0, \ldots, G_L\}$, $L = \left\lceil \lg m \right\rceil$, de subgrafos de $G$, de modo que para cada $G_i$ manteremos uma MSF $F_i$. 

As arestas de $F$ são chamadas de \textbf{arestas da floresta globais} e as arestas de $R = G / F$ são chamadas de \textbf{arestas reserva globais}. Similarmente, as arestas de $F_i$ são chamadas de \textbf{arestas da floresta locais} e as arestas de $R_i = G_i / F_i$ de \textbf{arestas reserva locais}. 

Até o momento, fica claro que há uma certa cadeia de dependências entre os algoritmos que estudamos e implementamos. Dessa forma, seria interessante apresentar os detalhes de como implementar a biblioteca deste algoritmo para MSF dinâmica. Para isso, entretanto, precisaríamos modificar a implementação da biblioteca da conexidade em florestas dinâmicas, que passaria a manter top trees no lugar de Euler tour trees. Como a nossa implementação da biblioteca de Euler tour trees possui um consumo de tempo diferente da implementação de top trees apresentada em Holm, de Lichtenberg e Thorup~\cite{jacob_holm}, a biblioteca que implementamos do algoritmo de conexidade em grafos dinâmicos teria a sua complexidade de tempo alterada, visto que este passaria a manter componentes destas florestas dinâmicas ajustadas. 

Além disso, ajustes na biblioteca do algoritmo de conexidade em grafos dinâmicos alteraria, por sua vez, o consumo de tempo da biblioteca que implementamos do algoritmo para MSF decremental. É após todos estes ajustes que, finalmente, poderíamos implementar o algoritmo para a MSF dinâmica proposta por Holm, de Lichtenberg e Thorup~\cite{jacob_holm} na Seção~$5$ de seu artigo. 

Em suma, dada a complexidade de se realizar estes ajustes nos algoritmos já implementados, optamos por não descrever a biblioteca de um algoritmo para MSF dinâmica e implementá-la.
