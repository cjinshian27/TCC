%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Conexidade em grafos dinâmicos}

\enlargethispage{.8\baselineskip}

Como citado no Capítulo~\ref{cap:introducao}, o problema da conexidade em grafos dinâmicos visa construir um algoritmo eficiente que dê suporte a inserções e remoções de arestas e consultas de conexidade entre dois vértices. O algoritmo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm} para este problema de conexidade mantém $\left\lceil \lg n \right\rceil$ florestas dinâmicas do grafo $G$, e utiliza uma biblioteca que será descrita na próxima seção. 

\section{Conexidade em florestas dinâmicas}
\label{sec:dynamic-forest-connectivity}

Rodrigues \cite{arthur}, em sua dissertação do mestrado, estudou, entre outros assuntos, o problema da conexidade em florestas dinâmicas e implementou o algoritmo que foi proposto na Seção~2 do artigo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm}. No Capítulo~2 da sua dissertação, Rodrigues descreve as rotinas principais de sua implementação, que se baseia em Euler tour trees, e realiza uma análise minuciosa da complexidade de tempo de cada rotina de sua implementação. Levando isso em conta, optamos por não apresentar uma descrição detalhada desse mesmo algoritmo, e apenas explicar brevemente o que as rotinas principais fazem, ressaltando algumas diferenças da nossa implementação em código em relação à de Rodrigues.  

O problema da conexidade em florestas dinâmicas pode ser considerado uma simplificação do problema de conexidade em grafos dinâmicos, quando o grafo em questão é uma floresta. A biblioteca que usaremos contém os seguintes métodos:

\begin{itemize}
    \item \texttt{\textbf{florestaDinâmica($n$)}}: constrói e devolve uma floresta dinâmica $F$ com $n$ vértices e sem arestas;
    \item \texttt{\textbf{conectadosFD($F$, $u$, $v$)}}: devolve verdadeiro se \textit{$u$} e \textit{$v$} estão na mesma componente da floresta $F$ e falso caso contrário;
    \item \texttt{\textbf{adicioneFD($F$, $u$, $v$)}}: insere uma aresta \textit{uv} na floresta $F$;
    \item \texttt{\textbf{removaFD($u$, $v$)}}: remove a aresta \textit{uv} da floresta $F$.
\end{itemize}


A estrutura de dados principal usada neste algoritmo de Holm, de Lichtenberg e Thorup~para dar suporte eficiente às rotinas acima é uma árvore binária de busca balanceada (ABBB). Uma floresta dinâmica é constituída de várias ABBBs. Rodrigues utiliza \textit{treaps} em sua implementação, que são de natureza aleatória. Em nosso caso, utilizamos árvores \texttt{splay}, que foram desenvolvidas por \textit{Sleator e Tarjan} \cite{sleator}. Árvores \texttt{splay} são árvores binárias de busca (ABBs) que possuem uma rotina extra (além das usuais de busca, inserção e remoção) chamada \texttt{splay}, que é acionada ao final de cada operação feita na árvore, de modo que é sempre aplicada ao nó mais profundo visitado. O nó em que a operação \texttt{splay} é aplicada é trazido, por meio das tradicionais rotações usadas no balanceamento de árvores binárias de busca, para cima até chegar na raiz da árvore. Isso faz com que o custo de uma sequência de $m$ operações (inserção, remoção ou busca) em uma árvore \texttt{splay} com $n$ nós seja $\Oh(m\lg n)$, ou seja, o custo amortizado por operação é $\Oh(\lg n)$. Como também já existe bastante literatura sobre árvores \texttt{splay}~\cite[Lecture 12]{kozen}, e seu funcionamento interno afeta muito pouco a descrição dos algoritmos que descreveremos, não entraremos em detalhes de sua implementação.

O resultado é uma implementação em que \texttt{florestaDinâmica(n)} tem custo $\Theta(n)$ e os demais métodos da biblioteca têm custo amortizado $\Oh(\lg n)$.

\section{Biblioteca do grafo dinâmico}
\label{sec:dynamic-graph-structure}

Implementar o grafo dinâmico resume-se à construção da seguinte biblioteca de forma eficiente:

\begin{itemize}
    \item \texttt{\textbf{grafoDinâmico($n$)}}: contrói e devolve um grafo dinâmico com $n$ vértices e sem arestas;
    \item \texttt{\textbf{conectadosGD($G$, $u$, $v$)}}: devolve verdadeiro se os vértices $u$ e $v$ estão na mesma componente de $G$ e falso caso contrário;
    \item \texttt{\textbf{adicioneGD($G$, $u$, $v$)}}: adiciona a aresta $uv$ no grafo $G$;
    \item \texttt{\textbf{removaGD($G$, $u$, $v$)}}: remove a aresta $uv$ do grafo $G$.
\end{itemize} 

Para entender como cada uma dessas rotinas funcionam, será necessário apresentar a estrutura interna da implementação do grafo para explicar como ele mantém essas estruturas e como elas deixam essas rotinas mais eficientes.

\subsection{Fatiamento do grafo em níveis}
\label{sec:level-slicing}

Na Seção~3.1 do artigo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm}, é apresentada a técnica de fatiar o grafo $G$ em níveis. Cada aresta do grafo possui um nível entre $1$ e $\left\lceil \lg n \right\rceil$, onde $n$ é o número de vértices do grafo $G$. Toda vez que inserimos uma aresta em $G$, ela possuirá o nível $\left\lceil \lg n \right\rceil$, e ele nunca será aumentado. 

Seja $G$ um grafo com conjunto $V(G)$ de vértices e conjunto $E(G)$ de arestas. Se $X$ é um conjunto não-vazio de arestas, dizemos que o subgrafo de $G$ \textbf{induzido} por $X$ é o subgrafo gerador $H$ de $G$ tal que $E(H) = X$. Denotamos, $H$ como $G[X]$.

Sendo assim, seja $G_i = G[X]$ o grafo onde $X$ é o conjunto das arestas do grafo $G$ de nível menor ou igual a $i$. Para cada nível $i$, manteremos uma floresta maximal $F_i$ de $G_i$. Além disso, vamos manter também, para cada nível $i$, um grafo $R_i$ em forma de listas de adjacências, que guardam apenas arestas de nível $i$ que não estejam em $F_i$. 

Consequentemente, temos que $G_1 \subseteq G_2 \subseteq \cdots \subseteq G_{\left\lceil \lg n \right\rceil}$, para um grafo $G$ de $n$ vértices, e deduzimos que $G = G_{\left\lceil \lg n \right\rceil}$ e que $F_{\left\lceil \lg n \right\rceil}$ é uma floresta maximal de $G$. Dessa maneira, sempre que estivermos realizando alguma operação de consulta de conexidade em nosso grafo~$G$, podemos realizá-la na floresta $F_{\left\lceil \lg n \right\rceil}$ de~$G$.

Com isso, podemos estabelecer algumas invariantes, que são mantidas ao longo das modificações no grafo $G$:

\begin{enumerate}[label=(\Roman*)]
    \item \label{invariant1} $F_i$ é uma floresta maximal de $G_i$ para todo $1 \leq i \leq  \left\lceil \lg n \right\rceil$;
    
    \item \label{invariant2} $F_i \subseteq F_{i+1}$ para todo $1 \leq i \leq \left\lceil \lg n \right\rceil - 1$;
    
    \item \label{invariant3} Cada componente da floresta $F_i$ possui no máximo $2^i$ vértices.
\end{enumerate}

Na Seção~\ref{sec:dynamic-graph-routines}, descreveremos com mais detalhes como as rotinas da biblioteca funcionam e como cada uma preserva as invariantes acima, de modo a manter a corretude do algoritmo durante toda a sua execução. Por fim, para simplificar um pouco a notação, escreveremos $L = \left\lceil \lg n \right\rceil$, isto é, $F_{\left\lceil \lg n \right\rceil}$ passa a ser escrita como $F_{L}$, da mesma forma que $G_L = G_{\left\lceil \lg n \right\rceil}$ e $R_L = R_{\left\lceil \lg n \right\rceil}$.

\subsection{Tipos de arestas do grafo}
\label{sec:dynamic-graph-edge-types}


Quando realizamos uma chamada à função \texttt{adicioneGD($G$, $u$, $v$)}, é feita uma chamada à rotina \texttt{conectadosGD($G$, $u$, $v$)} para verificar a conexidade de $u$ com $v$ em $G$. Se estes vértices não estiverem na mesma componente de $G$, então a aresta $uv$ é inserida na floresta maximal $F_L$ que estamos mantendo, assim ligando a árvore que contém $u$ com a que contém $v$ em $F_L$. Chamamos esse tipo de aresta de \textbf{aresta da floresta}.

Caso $u$ e $v$ já estejam conectados em $G$, então essa aresta $uv$ é chamada de \textbf{aresta reserva} e ela será armazenada no grafo $R_L$ representado por listas de adjacências, que contém a seguinte biblioteca:

\begin{itemize}
    \item \texttt{\textbf{listasDeAdjacências($n$)}}: constrói e devolve um grafo com $n$ vértices e sem arestas, representado por listas de adjacências;
    \item \texttt{\textbf{adicioneLA($R$, $u$, $v$)}}: adiciona $u$ na lista de adjacências de $v$ em $R$ e vice-versa;
    \item \texttt{\textbf{removaLA($R$, $u$, $v$)}}: remove $u$ da lista de adjacências de $v$ em $R$ e vice-versa.
\end{itemize} 

A nossa implementação \cite{chung2025} de listas de adjacências possui um custo $\Oh(n)$ ao acionar o construtor \texttt{listasDeAdjacências}, e para 
as rotinas \texttt{adicioneLA} e \texttt{removaLA} é garantido tempo esperado $\Oh(1)$, visto que estamos utilizando um mapa hash da linguagem \textit{C++} para realizar adição de um vizinho $v$ na lista de $u$ e remoção de $v$ da lista de adjacências de $u$.

\section{Rotinas da biblioteca do grafo dinâmico}
\label{sec:dynamic-graph-routines}

\subsection{Criação do grafo}
\label{sec:dynamic-graph-creation}

Para criar um grafo dinâmico $G$ com $n$ vértices e inicialmente sem arestas, acionamos a rotina \texttt{grafoDinâmico($n$)}. Nesta chamada, armazenamos o nível máximo do grafo, no caso o valor de $\left\lceil \lg n \right\rceil$, numa variável do grafo chamada \textit{nívelMax}, onde podemos extrair e usar o valor do nível máximo chamando \textit{$\dotvar{G}{nívelMax}$}. Em seguida, chamamos \texttt{florestaDinâmica($n$)}, que criará $\left\lceil \lg n \right\rceil$ florestas dinâmicas com $n$ vértices, e \texttt{listasDeAdjacências($n$)}, que criará $\left\lceil \lg n \right\rceil$ grafos com $n$ vértices representados por listas de adjacências. 

Além disso, usamos um mapa hash para guardar e obter o nível de uma aresta $uv$ em tempo esperado $\Oh(1)$. Assim, este mapa usa como chave as pontas da aresta ($u$~e~$v$) e armazena o valor do nível da aresta $uv$. Assim, podemos definir um outro método \texttt{novoMapaHash($n$)} que devolve um mapa hash vazio em tempo $\Oh(1)$ para um grafo de $n$ vértices. Dessa forma, se chamarmos esse método e atribuirmos o objeto devolvido a uma variável chamada \textit{nível}, podemos realizar as seguintes operações com \textit{nível}:

\begin{itemize}
    \item $\emph{nível[u, v]}$ $\leftarrow$ $i$: armazena $i$ como o nível da aresta $uv$.
    
    \item $\emph{nível[u, v]}$ $\leftarrow$ \texttt{NIL}: remove a aresta $uv$ do mapa hash.
    
    \item $x$ $\leftarrow$ $\emph{nível[u, v]}$: atribui o valor do nível da aresta $uv$ à variável $x$. 
\end{itemize}

Dessa forma, podemos apresentar o construtor do grafo no Programa~\ref{prog:newGD}. 

\begin{programruledcaption}{\texttt{grafoDinâmico($n$)} \label{prog:newGD}}
    \noindent\textbf{Entrada}: Recebe o número $n$ de vértices do grafo. \\
    \textbf{Saída}: Devolve um grafo dinâmico $G$ com $n$ vértices e sem arestas.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\left\lceil \lg n \right\rceil$
    $\dotvar{G}{nívelMax}$ := L
    \textbf{para} $i$ := $1$ \textbf{até} L \textbf{faça}
        $G.F_i$ := \texttt{florestaDinâmica($n$)}
        $G.R_i$ := \texttt{listasDeAdjacências($n$)}
    G.nível := \texttt{novoMapaHash($n$)}
    retorne G
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Como ambos \texttt{florestaDinâmica($n$)} e \texttt{listasDeAdjacências($n$)} consomem tempo $\Oh(n)$, então \texttt{grafoDinâmico($n$)} consome tempo $\Oh(n \lg n)$, pois estamos criando $\left\lceil \lg n \right\rceil$ florestas dinâmicas e listas de adjacências. Além disso, é fácil de ver que, ao final, as três invariantes valem.

\subsection{Consultas de conexidade}
\label{sec:dynamic-graph-connectivity-queries}

Para testar a conexidade entre dois vértices $u$ e $v$ no grafo $G$, basta chamarmos \texttt{conectadosGD($G$, $u$, $v$)}, que por sua vez aciona \texttt{conectadosFD($F_L$, $u$, $v$)}, pois $F_L$ é uma floresta maximal de $G$ pelo invariante \ref{invariant1}. O Programa~\ref{prog:connectedGD} mostra essa rotina.

\begin{programruledcaption}{\texttt{conectadosGD($G$, $u$, $v$)} \label{prog:connectedGD}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$. \\
    \textbf{Saída}: Devolve um booleano indicando se $u$ e $v$ estão conectados em $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    retorne \texttt{conectadosFD($G.F_L$, $u$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

\raggedbottom


A rotina \texttt{conectadosFD($F_L$, $u$, $v$)} em nossa implementação consome tempo amortizado $\Oh(\lg n)$, e, portanto, \texttt{conectadosGD($F_L$, $u$, $v$)} também terá o mesmo consumo de tempo amortizado.
Além disso, a rotina de consulta não altera o nosso grafo, incluindo florestas e listas de adjacências, já que não há nenhuma modificação neles. Isso implica que as invariantes são mantidas. 









\subsection{Inserções de arestas}

Como explicado na Seção~\ref{sec:dynamic-graph-edge-types}, inserimos uma aresta $uv$ no grafo $G$ chamando a rotina \texttt{adicioneGD($G$, $u$, $v$)} e, em seguida, testamos a conexidade de $u$ e $v$ chamando a rotina \texttt{conectadosGD($G$, $u$, $v$)}, e, dependendo do resultado, $uv$ pode ser inserida como aresta reserva ou como aresta da floresta. Assumindo que a aresta $uv$ não exista em $G$ no momento de sua inserção, temos dois cenários:

\begin{itemize}
    \item 
    Se os vértices $u$ e $v$ já estão conectados em $G$, então chamaremos a função \texttt{adicioneLA($R_L$, $u$, $v$)}, que armazenará $uv$ como aresta reserva de nível $L$ de $G$ em $R_L$. A Figura~\ref{fig:graph_reserve_edge_uv_addition} ilustra esse cenário.

\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
        

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (c) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};

        % reserve edges (normal red edges)
        \draw[reserve] (u) -- (v) node[midway, below] {};


    \end{tikzpicture}
    \caption{As arestas pretas são da floresta maximal $F_L$ do grafo. Como queremos inserir a aresta $uv$ e os vértices $u$ e $v$ já estão conectados pelo caminho $u \rightarrow a \rightarrow b \rightarrow c \rightarrow e \rightarrow v$, então armazenamos $uv$ como aresta reserva (em vermelho).}
    \label{fig:graph_reserve_edge_uv_addition}
\end{figure}

\begin{itemize}
    \item  Se $u$ e $v$ não estão conectados em $G$, então inserimos $uv$ como aresta da floresta $F_L$ de nível $L$, chamando a função \texttt{adicioneFD($F_L$, $u$, $v$)}. A Figura~\ref{fig:graph_tree_edge_uv_addition} ilustra esse cenário.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        added/.style={thick, green},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.6cm);
        \draw[dotted, thick, gray] (4,2) circle (2.6cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        \draw[added] (u) -- (v) node[midway, below] {};

        % reserve edges (normal red edges)


    \end{tikzpicture}
    \caption{As arestas pretas são da floresta maximal $F_L$ do grafo. Como os vértices $u$ e $v$ não estão conectados em $F_L$, então inserimos $uv$ como aresta da floresta (em verde), nesse caso conectando as componentes $T_u$ e $T_v$ de $F_L$.}
    \label{fig:graph_tree_edge_uv_addition}
\end{figure}

O Programa~\ref{prog:addGD} ilustra uma primeira versão da rotina \texttt{adicioneGD}. Posteriormente, faremos alguns ajustes nessa rotina por causa da rotina de remoção de arestas explicada na Seção~\ref{sec:dynamic-graph-edge-removal}.

\begin{programruledcaption}{\texttt{adicioneGD($G$, $u$, $v$)} \label{prog:addGD}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := L
    \textbf{se} \texttt{conectadosFD($G.F_L$, $u$, $v$)} \textbf{então}
        \texttt{adicioneLA($G.R_L$, $u$, $v$)}
    \textbf{senão}
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

\raggedbottom

% Ao inserirmos uma aresta reserva $uv$ em $G$, precisamos atualizar o atributo \textit{incideArestaReservaDeNível} de $u$ e de $v$ para verdadeiro, se necessário. A Seção~\ref{sec:graph-nodes} explica com mais detalhes o método auxiliar (\texttt{incrementeArestasReservasDeNível}) usado. 

Em nossa implementação, \texttt{conectadosFD} consome tempo amortizado $\Oh(\lg n)$. A rotina \texttt{adicioneLA}, quando acionada, consome tempo esperado constante $\Oh(1)$ em nossa implementação por conta do mapa hash. Já inserir uma aresta da floresta chamando \texttt{adicioneFD} consome tempo $\Oh(\lg n)$ (amortizado, em nossa implementação). Portanto, a rotina \texttt{adicioneGD} tem custo de tempo amortizado $\Oh(\lg n)$.

A invariante \ref{invariant1} se mantém para o nível $i = \left\lceil \lg n \right\rceil$. Como sempre adicionamos arestas com nível $\left\lceil \lg n \right\rceil$ em $F_{\left\lceil \lg n \right\rceil}$ (se não forem reservas), então as outras florestas de níveis inferiores não são afetadas, mantendo-se, assim, os invariantes \ref{invariant2} e \ref{invariant3} também.























































\subsection{Remoção de arestas}
\label{sec:dynamic-graph-edge-removal}

A remoção de arestas se divide em dois casos: remoção de uma aresta reserva ou remoção de uma aresta da floresta.

Quando queremos remover uma aresta $uv$ e ela é reserva, podemos simplesmente acionar a rotina \texttt{removaLA($R_i$, $u$, $v$)} onde $i$, obtido do mapa hash, é o nível da aresta $uv$ e $R_i$ é a lista de adjacências na qual $uv$ está armazenada. Por conta disso, nenhuma das florestas maximais $F_j$ do grafo será afetada, e as três invariantes serão mantidas. A Figura~\ref{fig:graph_reserve_edge_removal} mostra esse cenário.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        removed_reserve/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (c) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};
        \draw[removed_reserve] (u) -- (v) node[midway, below] {};
        \draw[reserve] (c) -- (u) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

    \end{tikzpicture}
    \caption{As arestas pretas são da floresta maximal $F_L$ do grafo, enquanto as vermelhas são arestas reserva. A aresta vermelha $uv$ tracejada é reserva e está prestes a ser removida.}
    \label{fig:graph_reserve_edge_removal}
\end{figure}

O caso da remoção de uma aresta $uv$ da floresta é mais complexo. Se a aresta $uv$ tem nível $i$, remover $uv$ sempre quebra uma componente de $F_i$ em duas árvores $T_u$ e $T_v$, de modo que a primeira contém o vértice $u$ e a segunda contém o vértice $v$. Neste caso, precisamos verificar se existe alguma aresta reserva que ligue $T_u$ a $T_v$, para que possamos garantir que a floresta $F_i$ continue maximal em $G_i$. Chamamos uma tal aresta de \textbf{aresta substituta}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.6cm);
        \draw[dotted, thick, gray] (4,2) circle (2.6cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[removed] (u) -- (v) node[midway, above] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        \draw[reserve] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};

        % reserve edges (normal red edges)
        \draw[reserve] (b) -- (u) node[midway, below] {};
        \draw[reserve] (c) -- (u) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

    \end{tikzpicture}
    \caption{As arestas pretas são da floresta maximal $F_i$ do grafo $G_i$, enquanto as vermelhas são reservas de nível $i$. A aresta $uv$ tracejada de nível $i$ está prestes a ser removida, assim ela pode ser substituída por $ad$ ou $cv$, pois qualquer uma destas liga $T_u$ a $T_v$.}
    \label{fig:graph_with_Tu_and_Tv_with_reserve_edge}
\end{figure}

Para buscar uma aresta reserva de maneira o mais eficiente possível, o algoritmo percorre cada vértice $x$ de $T_u$ e verifica se existe algum vértice $y$ na lista de adjacências de $x$ de $R_i$ que esteja em $T_v$. Se $y \in V(T_v)$, então a aresta $xy$ é uma aresta substituta de nível $i$, bastando apenas acionar \texttt{adicioneFD($F_i$, $x$, $y$)} para reconectar $T_u$ e $T_v$, que virariam uma única componente da floresta $F_i$, e acionar \texttt{removaLA($R_i$, $x$, $y$)} já que $xy$ se tornará uma aresta da floresta.

É por este motivo que introduzimos o fatiamento em níveis na Seção~\ref{sec:level-slicing}. A intuição por trás deste fatiamento é que, quando uma aresta de nível $i$ da floresta é removida, não é necessário buscar por substitutas nos níveis menores que $i$. Isso quer dizer que começamos a busca no nível em questão, ou seja, em $R_i$, e caso não haja nenhuma substituta em $R_i$, passamos a procurar em $R_{i+1}, R_{i + 2}, \ldots, R_L$. Quando não encontramos uma substituta em um certo $R_i$, aproveitamos para rebaixar o nível de todas as arestas percorridas em $R_i$ para $i - 1$, de modo que não precisaremos mais percorrer essas arestas quando removermos uma outra aresta de nível $i$, visto que elas já estariam em $R_{i-1}$.


Na verdade, antes de fazer esse rebaixamento, rebaixamos o nível de toda aresta de nível $i$ de $T_u$ para $i-1$, de modo que $T_u \subseteq F_{i-1}$.
Rebaixar o nível dessas arestas significa inseri-las em $F_{i-1}$, pois elas passam a ser de nível $i-1$. Esse rebaixamento e as inserções em $F_{i-1}$ se tornam necessários para preservar a invariante~\ref{invariant1}. Ao mesmo tempo, para manter também a invariante~\ref{invariant3}, esse processo deverá ser feito na menor das árvores $T_u$ e $T_v$. Seja $T = T_u \cup T_v + uv$ . Denotando o número de vértices de uma árvore $T$ por $|T|$, o algoritmo garantirá que $|T_u| \leq |T_v|$. Pela invariante~\ref{invariant3}, temos que $|T| \leq 2^i$, e como $|T_u| + |T_v| = |T|$, então $|T_u| \leq 2^{i-1}$. Por isso, ao rebaixarmos todas as arestas de nível $i$ de $T_u$ para o nível $i-1$, preservamos a invariante~\ref{invariant3}. 

Ao remover uma aresta de nível $i$ da floresta, na verdade temos que removê-la não só de $F_i$, mas também de $F_{i + 1}, \ldots, F_{L}$ pela invariante~\ref{invariant2}. Similarmente, quando encontramos uma aresta substituta de nível $i$, temos que acrescentá-la não só a $F_i$, mas também a $F_{i+1}, \ldots, F_{L}$ para manter as invariantes~\ref{invariant1} e \ref{invariant2}. A invariante~\ref{invariant3} neste caso é mantida trivialmente.

Agora, veremos em detalhes o motivo de não precisarmos procurar uma substituta em níveis menores que $i$ quando removemos uma aresta $uv$ de nível $i$. Veja que, como a aresta $uv$ tem nível $i$, ela não pertence a $F_{i-1}$. Logo, pela invariante~\ref{invariant2}, $u$ e $v$ estão em componentes distintas de $F_{i-1}$. Como $F_{i-1}$ é maximal em $G_{i-1}$, não existe aresta reserva de nível $\leq i - 1$ que conecte as componentes $T_u$ e $T_v$. Portanto, só procuramos uma substituta em níveis $\geq i$. A Figura~\ref{fig:why-not-search-in-less-or-equal-than-i} torna a explicação mais intuitiva.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[>=stealth, thick]

    % Big green circles g1 and g2
    \node[draw, thick, green, circle, minimum size=2.9cm] (g1) at (-3,0) {};
    \node[draw, thick, green, circle, minimum size=2.9cm] (g2) at (3,0) {};

    \draw[dotted, thick, gray] (-3,0) circle (1.6cm);
    \draw[dotted, thick, gray] (3,0) circle (1.6cm);  
    
    % Labels for the circles
    \node at (-3,2) {$T_u$};
    \node at (3,2) {$T_v$};

    % Straight green edge between g1 and g2
    \draw[thick, green] (g1) -- node[above] {$i$} (g2);

    % Small red circles inside g1
    \node[draw, thick, red, circle, minimum size=1.2cm] (r11) at (-3.4,0.6) {};
    \node[draw, thick, red, circle, minimum size=1.2cm] (r12) at (-2.6,-0.5) {};

    % Small red circles inside g2
    \node[draw, thick, red, circle, minimum size=1.1cm] (r21) at (2.5, 0.6) {};
    \node[draw, thick, red, circle, minimum size=1.1cm] (r22) at (3.7, 0.1) {};
    \node[draw, thick, red, circle, minimum size=1.1cm] (r23) at (2.7,-0.6) {};

    % Curved red edge connecting one red circle in g1 with one in g2
    \draw[thick, red] (r11.north east) to[bend left=20] node[pos=0.5, above] {$i-1$} (r21.north west);

    \end{tikzpicture}
    \caption{Os círculos verdes representam as componentes $T_u$ e $T_v$ da floresta $F_i$ do grafo $G_i$, enquanto os círculos vermelhos representam as componentes da floresta $F_{i-1}$ do grafo $G_{i-1}$. Note que a aresta reserva de nível $i-1$ mostrada não deveria existir, porque senão ela violaria a invariante~\ref{invariant1}. Portanto, tais arestas de nível $i-1$ ligando componentes de $F_i$ (como a aresta vermelha) não existem e só é necessário procurar arestas substitutas a partir de nível $i$ (como a aresta verde) para conectar $T_u$ e $T_v$.}
    \label{fig:why-not-search-in-less-or-equal-than-i}
\end{figure}

\raggedbottom
A seguir, demonstraremos a remoção de uma aresta $uv$ da floresta em uma série de imagens. Na Figura~\ref{fig:example-replacement1}, temos um grafo $G$ de $n = 10$ vértices. Para facilitar, assumiremos que, até o momento, só houve inserções de arestas. 

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        % reserve edges (normal red edges)
        
        \draw[removed] (u) -- (v) node[midway, below] {};
        \draw[reserve] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};
        \draw[reserve] (b) -- (u) node[midway, below] {};
        \draw[reserve] (c) -- (u) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            %\draw[edge] (a) -- (u) node[midway, below] {};
            %\draw[edge] (a) -- (b) node[midway, below] {};
            %\draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Um grafo $G$ de 10 vértices, onde as arestas pretas são da floresta $F_4$, enquanto as vermelhas são reservas. A aresta $uv$ está prestes a ser removida. A floresta $F_{4}$ de $G$ de cima contém todas as arestas pretas recém-inseridas e as arestas vermelhas estão em $R_4$. A floresta de baixo é a $F_{3}$, com os vértices isolados, e $R_3$ também não tem nenhuma aresta.}
    \vspace{-1cm}
    \label{fig:example-replacement1}
\end{figure}

\raggedbottom

Temos também que $n = 10$ e $\left\lceil \lg 10 \right\rceil = 4$, logo o nível máximo $L$ da floresta é $4$ e,  consequentemente, $G = G_4$. Como todas as inserções só acontecem no nível $L$, no momento, em $F_4$, só temos arestas da floresta de nível $4$, enquanto $F_3$ contém apenas vértices isolados. Neste cenário, note que a remoção da aresta $uv$ da floresta, representada por uma linha tracejada na figura, acaba quebrando a única componente da floresta $F_4$ em duas, $T_u$ e $T_v$. Como $F_4$ é a floresta maximal de nível máximo de $G$, então removemos somente a $uv$ de $F_4$. 

O próximo passo é rebaixar todas as arestas de nível~$4$ em $T_u$ para o nível~$3$. Dessa forma, as arestas de $T_u$ passam a estar em $F_3$, como se pode ver na Figura~\ref{fig:example-replacement2}, pois agora elas passam a ser de nível $3$.  

Perceba que, devido à invariante~\ref{invariant2}, podemos ter arestas de diferentes níveis em uma mesma floresta. Assim, percorrer todas as arestas de $T_u$ e selecionar apenas as de nível~$i$ para rebaixar pode se tornar demorado quando o grafo possui uma grande quantidade de vértices. A forma como o algoritmo procura as arestas de nível $i$ de $T_u$ será descrita de maneira mais detalhada na Seção~\ref{sec:node-edge}. No momento, só precisamos entender como este rebaixamento funciona.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        % reserve edges (normal red edges)
        
        \draw[reserve] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};
        \draw[reserve] (b) -- (u) node[midway, below] {};
        \draw[reserve] (c) -- (u) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            
            \draw[edge] (a) -- (u) node[midway, below] {};
            \draw[edge] (a) -- (b) node[midway, below] {};
            \draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da remoção da aresta $uv$ em $G$. As arestas de nível $4$ de $T_u$ foram rebaixadas para o nível $3$, o que pode ser visto na floresta $F_{3}$.}
    \vspace{-1cm}
    \label{fig:example-replacement2}    
\end{figure}

\raggedbottom

Como $T_u$ e $T_v$ em $F_4$ ficaram separadas após a remoção de $uv$, precisamos encontrar, se existir, uma aresta reserva que possa reconectá-las. Note que percorrer todas as arestas reserva para achar uma substituta que ligue $T_u$ a $T_v$ pode ser ineficiente quando temos muitas arestas reserva. Por isso, explicaremos como implementar essa busca por uma substituta de forma eficiente na Seção~\ref{sec:node-vertex}. 

Na Figura~\ref{fig:example-replacement3}, percorremos as arestas reserva em $R_4$ que tenham uma das pontas em~$T_u$. Para cada aresta percorrida, verificamos se a outra ponta dela incide em algum vértice de $T_v$. Caso não incida, a aresta tem duas pontas em $T_u$, pois $F_4$ era maximal antes da remoção de $uv$, e logo a aresta não é uma substituta.  Então a rebaixamos para o nível $3$, ou seja, movemos de $R_4$ para $R_3$ as arestas  percorridas que não são substitutas.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        % reserve edges (normal red edges)
  
        \draw[reserve] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};
        \draw[reserveremoved] (b) -- (u) node[midway, below] {};
        \draw[reserveremoved] (c) -- (u) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            
            % Dotted circles for T_u and T_v
            \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
            \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
            
            % Labels for the circles
            \node at (-3,-1.1) {$T_u$};
            \node at (4,-1.1) {$T_v$};
            
            \draw[reserve] (b) -- (u) node[midway, below] {};
            \draw[reserve] (c) -- (u) node[midway, below] {};
            \draw[edge] (a) -- (u) node[midway, below] {};
            \draw[edge] (a) -- (b) node[midway, below] {};
            \draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da busca por uma aresta substituta em $R_4$. As arestas reserva de nível $4$ que estão tracejadas foram percorridas e estão prestes a ser removidas de $R_4$, pois foram rebaixadas para o nível $3$, como se pode ver em $R_3$.}
    \vspace{-1cm}
    \label{fig:example-replacement3}
\end{figure}


Supondo que achamos a aresta $ad$ como substituta de nível $4$ antes de $cv$, conectamos $T_u$ e $T_v$ chamando \texttt{adicioneFD($F_4$, a, d)} e $ad$ passa a ser uma aresta da floresta, ou seja, é removida de $R_4$. Como $i = 4$ é o nível máximo do grafo nesse exemplo, não precisamos chamar esta rotina para os níveis superiores e então terminamos a execução do algoritmo. A Figura~\ref{fig:example-replacement4} ilustra essa etapa do algoritmo.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        % tree edges (normal black edges)
        \draw[edge] (a) -- (u) node[midway, below] {};
        \draw[edge] (a) -- (b) node[midway, below] {};
        \draw[edge] (b) -- (c) node[midway, below] {};
        \draw[edge] (v) -- (d) node[midway, below] {};
        \draw[edge] (v) -- (f) node[midway, below] {};
        \draw[edge] (v) -- (e) node[midway, below] {};
        \draw[edge] (f) -- (g) node[midway, below] {};
        \draw[edge] (g) -- (h) node[midway, below] {};
        % reserve edges (normal red edges)
        
        \draw[edge] (a) -- (d) node[midway, below] {};
        \draw[reserve] (c) -- (v) node[midway, below] {};
        \draw[reserve] (d) -- (f) node[midway, below] {};
        \draw[reserve] (d) -- (h) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            
            % Dotted circles for T_u and T_v
            \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
            \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
            
            % Labels for the circles
            \node at (-3,-1.1) {$T_u$};
            \node at (4,-1.1) {$T_v$};
            
            \draw[reserve] (b) -- (u) node[midway, below] {};
            \draw[reserve] (c) -- (u) node[midway, below] {};
            \draw[edge] (a) -- (u) node[midway, below] {};
            \draw[edge] (a) -- (b) node[midway, below] {};
            \draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação do grafo com a aresta substituta $ad$ escolhida para conectar $T_u$ a $T_v$, tornando-se uma aresta da floresta $F_4$.}
    \vspace{-1cm}
    \label{fig:example-replacement4}
\end{figure}

Quando removemos uma aresta da floresta de nível $i$ que quebra uma componente da floresta $F_i$ em duas, $T_u$ e $T_v$, com $|T_u| \leq |T_v|$, note que ao procurar por uma aresta substituta não necessariamente percorreremos todas as arestas reserva em $R_i$ incidentes a $T_u$. Então nem sempre todas as arestas reserva de $R_i$ incidentes a $T_u$ são rebaixadas, visto que o algoritmo será finalizado no momento em que encontrarmos uma substituta.

O Programa~\ref{prog:removeGD} apresenta uma primeira versão da rotina \texttt{removaGD}. Ela contém uma chamada à rotina \texttt{substituaAresta} que será explicada Seção~\ref{sec:replace-edge}. Alguns ajustes em \texttt{removaGD} serão necessários devido à implementação da rotina \texttt{substituaAresta}. 
Em particular, essa rotina deve percorrer as arestas da floresta e as arestas reserva de maneira eficiente. Apresentaremos a estratégia usada para isso nas Seções~\ref{sec:node-edge}~e~\ref{sec:node-vertex}.

\begin{programruledcaption}{\texttt{removaGD($G$, $u$, $v$)} \label{prog:removeGD}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ adjacentes do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    i := $\dotvarm{G}{nível}{u,v}$
    $\emph{nível[u, v]}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    L := $\dotvar{G}{nívelMax}$
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        \textbf{para} j := i \textbf{até} $L$ \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaAresta($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLA($G.R_i$, $u$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Note que \texttt{removaGD} consome $\Oh(\lg^2 n)$ mais o tempo do \texttt{substituaAresta}, que será descrito mais adiante.







































\section{Estrutura interna do grafo dinâmico}
\label{sec:dynamic-graph-implementation}

Para explicar a rotina \texttt{substituaAresta}, precisamos saber mais detalhes sobre como as árvores de cada floresta $F_i$ são armazenadas. Apresentaremos esses detalhes a seguir.

\subsection{Euler tour trees}
\label{sec:euler-tour-trees}

A Seção~2.1 do artigo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propõe o uso de Euler tour trees, que é uma técnica utilizada para representar uma árvore. Essa representação é obtida de uma árvore $T$ substituindo-se cada aresta por dois arcos em sentidos opostos e adicionando-se um laço a cada vértice, como pode ser visto na Figura~\ref{fig:euler-tour-trees}. 

O digrafo resultante de $T$ é Euleriano, ou seja, é conexo e o grau de entrada de cada vértice é igual ao grau de saída. Consequentemente, há uma trilha que começa e termina num mesmo vértice, passando por todos os arcos do digrafo somente uma vez. Tal trilha é chamada de \textbf{ciclo Euleriano}.

\begin{figure}[H]
    \centering
\begin{tikzpicture}[scale=0.6, thick, node distance=2cm,
  vtx/.style={draw, circle, minimum size=8mm, inner sep=0pt}]

% ---------- Left: original graph ----------
\node[vtx] (a) at (0,0) {$a$};
\node[vtx] (b) at (1.5,1.5) {$b$};
\node[vtx] (c) at (3,0) {$c$};
\node[vtx] (d) at (1.5,-1.5) {$d$};
\node[vtx] (e) at (-1.5,-1.5) {$e$};

% Graph edges
\draw (a) -- (b);
\draw (c) -- (d);
\draw (d) -- (a);
\draw (a) -- (e);

% \node[vtx] (a) at (0,0) {$a$};
% \node[vtx] (b) at (1.5,1.5) {$b$};
% \node[vtx] (c) at (3,0) {$c$};
% \node[vtx] (d) at (1.5,-1.5) {$d$};
% \node[vtx] (e) at (-1.5,-1.5) {$e$};

% ---------- Right: Euler-tour representation ----------
\begin{scope}[xshift=8cm]
  \node[vtx] (a1) at (0,0) {$a$};
  \node[vtx] (b1) at (1.5, 1.5) {$b$};
  \node[vtx] (c1) at (3,0) {$c$};
  \node[vtx] (d1) at (1.5,-1.5) {$d$};
  \node[vtx] (e1) at (-1.5,-1.5) {$e$};

  % Bidirectional arcs
  \draw[->] (a1) to[bend left=20] (b1);
  \draw[->] (b1) to[bend left=20] (a1);

  \draw[->] (c1) to[bend left=20] (d1);
  \draw[->] (d1) to[bend left=20] (c1);

  \draw[->] (d1) to[bend left=20] (a1);
  \draw[->] (a1) to[bend left=20] (d1);

  \draw[->] (a1) to[bend left=20] (e1);
  \draw[->] (e1) to[bend left=20] (a1);

  \draw[->] (a1) edge[loop above] ();
  \draw[->] (b1) edge[loop above] ();
  \draw[->] (c1) edge[loop right] ();
  \draw[->] (d1) edge[loop below] ();
  \draw[->] (e1) edge[loop left] ();

\end{scope}

\end{tikzpicture}
    \caption{À esquerda, temos uma árvore $T$ e, à direita, temos o digrafo Euleriano de $T$.}
    \label{fig:euler-tour-trees}
\end{figure}

\raggedbottom

A representação da árvore $T$ é basicamente a sequência de arcos que forma um ciclo Euleriano do digrafo correspondente a $T$. Denotamos cada arco pelo par de vértices que o compõe. Dessa forma, se o arco parte de $u$ para $v$, ele será denotado como $uv$. Para o caso do laço em um vértice $u$, então o arco será escrito como $uu$. Assim, no exemplo da Figura~\ref{fig:euler-tour-trees}, um possível ciclo Euleriano poderia ser o seguinte: 
\begin{equation}
\textit{ee ea aa ab bb ba ad dd dc cc cd da ae}.
\label{eq:euler-sequence}
\end{equation}

A sequência dos arcos obtida de $T$ depende do vértice inicial e da ordem em que os vizinhos de cada vértice são visitados. Uma tal sequência é chamada \textbf{sequência Euleriana} de $T$. 

Henzinger e King \cite{henzinger_king} propuseram armazenar uma sequência Euleriana em uma árvore binária de busca balanceada, usando como chave a posição de cada elemento na sequência. Tomando como base o nosso exemplo da árvore da Figura~\ref{fig:euler-tour-trees} e sua sequência Euleriana dada em~(\refeq{eq:euler-sequence}), podemos ilustrar uma possível árvore binária de busca balanceada para ela na Figura~\ref{fig:euler-tour-balanced-tree}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node] (ad) at (0, 0) {$ad$};
        \node[node] (ab) at (-4.5, -1.5) {$ab$};
        \node[node] (cd) at (4.5, -1.5) {$cd$};
        \node[node] (dc) at (3, -3) {$dc$};
        \node[node] (dd) at (1.5, -4.5) {$dd$};
        \node[node] (cc) at (4.5, -4.5) {$cc$};
        
        
        
        \node[node] (da) at (6, -3) {$da$};
        \node[node] (ae) at (7.5, -4.5) {$ae$};
        
        
        \node[node] (ea) at (-6, -3) {$ea$};
        \node[node] (ee) at (-7.5, -4.5) {$ee$};
        \node[node] (aa) at (-4.5, -4.5) {$aa$};


        \node[node] (bb) at (-3, -3) {$bb$};
        \node[node] (ba) at (-1.5, -4.5) {$ba$};

        

        % tree edges (normal black edges)
        \draw[edge] (ad) -- (ab) node[midway, below] {};
        \draw[edge] (ad) -- (cd) node[midway, below] {};
        \draw[edge] (cd) -- (dc) node[midway, below] {};
        \draw[edge] (cd) -- (da) node[midway, below] {};
        \draw[edge] (bb) -- (ba) node[midway, below] {};
        \draw[edge] (ea) -- (ee) node[midway, below] {};
        \draw[edge] (ea) -- (aa) node[midway, below] {};
        \draw[edge] (dc) -- (dd) node[midway, below] {};
        \draw[edge] (dc) -- (cc) node[midway, below] {};
        \draw[edge] (da) -- (ae) node[midway, below] {};

        \draw[edge] (ab) -- (ea) node[midway, below] {};
        \draw[edge] (ab) -- (bb) node[midway, below] {};


    \end{tikzpicture}
    \caption{Uma árvore binária de busca balanceada para um ciclo Euleriano da árvore da Figura~\ref{fig:euler-tour-trees}. Note que se percorrermos os nós da árvore acima em \textit{inorder}, obtemos a sequência Euleriana de (\ref{eq:euler-sequence}).}
    \label{fig:euler-tour-balanced-tree}
\end{figure}

\raggedbottom

Além disso, Henzinger e King \cite{henzinger_king} propuseram representar uma floresta pela coleção de sequências Eulerianas de cada componente da floresta. Assim, é possível implementar as operações de consulta de conexidade e de alteração na floresta com consumo esperado de tempo $\Oh(\lg n)$ (amortizado em nossa implementação), onde $n$ é o número de nós da floresta. O algoritmo de Holm, de Lichtenberg e Thorup~\cite{jacob_holm} armazena cada floresta $F_i$ em uma estrutura dessas.

\subsection{Nós das florestas}
\label{sec:graph-nodes}

Os nós das árvores binárias de busca que representam as sequências Eulerianas que são mantidas pelo algoritmo serão chamados de \textbf{nós das florestas}. Cada tal nó pode representar um vértice $u$ do grafo, se o elemento armazenado no nó for $uu$, ou pode representar uma aresta $uv$ do grafo, se o elemento armazenado no nó for $uv$ ou $vu$, com $u \neq v$. O primeiro tipo de nó é chamado de \textbf{nó de vértice} e o segundo, de \textbf{nó de aresta}. Em nossa implementação, para cada floresta $F_i$, usaremos um mapa hash \textit{nó} que armazena, para cada par de vértices $(u, v)$, um apontador para o nó do elemento $uv$ na floresta $F_i$, se tal nó existe (ou \texttt{NIL} caso não exista).

Como representamos uma Euler tour tree por uma árvore binária de busca, cada nó $p$ possui apontadores para o filho esquerdo, filho direito e seu pai. Na descrição de nossa implementação, denotamos tais apontadores por \textit{p.esq}, \textit{p.dir} e \textit{p.pai}, respectivamente. O motivo de usar o apontador para o pai é por conta da operação \texttt{splay}.

Além disso, para extrairmos as pontas de um nó de aresta $p$ que representa $xy$, usamos os campos \textit{p.vértice1} e \textit{p.vértice2}, que guardam os valores  $x$ e $y$, respectivamente. Em um nó de vértice $q$ que representa $xx$, \textit{q.vértice1} guarda o mesmo valor do \textit{q.vértice2}, ou seja, ambos armazenam $x$. Podemos extrair ambas as pontas do nó $p$ chamando $p$.\emph{vértices}. Extrair as pontas dos nós será importante como veremos em vários métodos posteriormente. 

A seguir, descreveremos a funcionalidade de cada tipo de nó, bem como outros atributos relevantes que lhe pertencem. 

\subsection{Nó de aresta}
\label{sec:node-edge}

Como já observamos, na floresta $F_i$, há arestas de nível $\leq i$. Para percorrermos as arestas de nível $i$ de uma componente de $F_i$ eficientemente, os nós da floresta $F_i$ têm um atributo extra booleano chamado \textit{éNível}, que, em caso de um nó de aresta, indica se tal aresta da floresta $F_i$ é de nível $i$. 

Além disso, todos os nós da floresta armazenam um contador chamado \textit{arestasDeNível}, com a quantidade de nós em sua subárvore que têm o atributo \textit{éNível} verdadeiro. Sempre que modificarmos alguma das árvores binárias da floresta $F_i$, devemos manter este contador com o valor correto. Na nossa implementação, a atualização deste contador é feita na operação \texttt{splay} sempre que essa executa alguma rotação.

A rotina abaixo do Programa~\ref{prog:updateIsLevel-GD} é usada para alterar para $b$ o valor do atributo \textit{éNível} para uma aresta $uv$. Ela é acionada sempre que adicionamos uma aresta ao grafo, e também quando uma aresta é rebaixada. Tal rotina utiliza um método auxiliar chamado \textit{atualizeArestasDeNível}, descrito no Programa~\ref{prog:updateIsLevelCount-GD}.

\begin{programruledcaption}{\texttt{atualizeÉNível($F$, $u$, $v$, $b$)} \label{prog:updateIsLevel-GD}}
    \noindent\textbf{Entrada}: Recebe uma floresta $F$, pontas $u$ e $v$ de uma aresta de $G$, e um booleano $b$.\\
    \noindent\textbf{Efeito}: Atualiza o atributo \textit{éNível} do nó $uv$ da floresta $F$ e o contador \textit{arestasDeNível}.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    arestaUV := F.nó[u, v] 
    \texttt{splay($\emph{arestaUV}$)}
    arestaUV.éNível := b
    \texttt{atualizeArestasDeNível($\emph{arestaUV}$)}
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

\begin{programruledcaption}{\texttt{atualizeArestasDeNível($\emph{p}$)} \label{prog:updateIsLevelCount-GD}}
    \noindent\textbf{Entrada}: Recebe um nó $p$.\\
    \noindent\textbf{Efeito}: Atualiza o contador \textit{arestasDeNível} de $p$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    c := 0
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{então}
        c := c + \textit{p.esq.arestasDeNível}
    \textbf{se} p.dir $\neq$ \texttt{NIL} \textbf{então}
        c := c + \textit{p.dir.arestasDeNível}
    \textbf{se} p.éNível \textbf{então}
        c := c + 1
    p.arestasDeNível := c
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}


Como se pode ver, o Programa~\ref{prog:updateIsLevelCount-GD} consome tempo $\Oh(1)$. Já Programa~\ref{prog:updateIsLevel-GD} consome tempo amortizado $\Oh(\lg n)$ por conta da operação \texttt{splay}. Veja que ambos os métodos não alteram a floresta $F_i$, alteram apenas uma das árvores binárias que a representam. Portanto, todas as três invariantes são preservadas.

Usando o mesmo exemplo da Figura~\ref{fig:euler-tour-balanced-tree} na Seção~\ref{sec:euler-tour-trees}, podemos ilustrar como estaria o atributo \textit{arestasDeNível} de cada nó na árvore. Na nossa implementação, os vértices são identificados por inteiros de $1$ a $n$ e, para uma aresta $uv$, usamos o atributo \textit{éNível} apenas para o nó de $uv$ com $u < v$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node, fill=red!30, label=below:{4}] (ad) at (0, 0) {$ad$};
        \node[node, fill=red!30, label=below:{1}] (ab) at (-4.5, -1.5) {$ab$};
        \node[node, fill=red!30, label=below:{2}] (cd) at (4.5, -1.5) {$cd$};
        \node[node, label=below:{0}] (dc) at (3, -3) {$dc$};
        \node[node, label=below:{0}] (dd) at (1.5, -4.5) {$dd$};
        \node[node, label=below:{0}] (cc) at (4.5, -4.5) {$cc$};
        
        
        \node[node, label=below:{1}] (da) at (6, -3) {$da$};
        \node[node, fill=red!30, label=below:{1}] (ae) at (7.5, -4.5) {$ae$};
        
        
        \node[node, label=below:{0}] (ea) at (-6, -3) {$ea$};
        \node[node, label=below:{0}] (ee) at (-7.5, -4.5) {$ee$};
        \node[node, label=below:{0}] (aa) at (-4.5, -4.5) {$aa$};


        \node[node, label=below:{0}] (bb) at (-3, -3) {$bb$};
        \node[node, label=below:{0}] (ba) at (-1.5, -4.5) {$ba$};

        

        % tree edges (normal black edges)
        \draw[edge] (ad) -- (ab) node[midway, below] {};
        \draw[edge] (ad) -- (cd) node[midway, below] {};
        \draw[edge] (cd) -- (dc) node[midway, below] {};
        \draw[edge] (cd) -- (da) node[midway, below] {};
        \draw[edge] (bb) -- (ba) node[midway, below] {};
        \draw[edge] (ea) -- (ee) node[midway, below] {};
        \draw[edge] (ea) -- (aa) node[midway, below] {};
        \draw[edge] (dc) -- (dd) node[midway, below] {};
        \draw[edge] (dc) -- (cc) node[midway, below] {};
        \draw[edge] (da) -- (ae) node[midway, below] {};

        \draw[edge] (ab) -- (ea) node[midway, below] {};
        \draw[edge] (ab) -- (bb) node[midway, below] {};


    \end{tikzpicture}
    \caption{Árvore de uma das componentes da floresta $F_i$, onde nós pintados em vermelho indicam arestas de nível $i$, e logo possuem o atributo éNível verdadeiro. Embaixo de cada nó temos o valor do contador arestasDeNível.}
    \label{fig:euler-tour-balanced-tree-is-level-propagation}
\end{figure}

Na Figura~\ref{fig:euler-tour-balanced-tree-is-level-propagation}, note que os nós $\emph{ab}$ e $\emph{ba}$ representam a mesma aresta. Assim, para evitar a duplicação do atributo \textit{éNível}, optamos por colocar este atributo como verdadeiro somente nos nós de aresta cujos vértices estão em ordem lexicográfica. Então, no nosso exemplo, nós do tipo $\emph{ba}$, $\emph{da}$, $\emph{dc}$ e $\emph{ea}$ vão ter este atributo falso. 

Lembre-se que a remoção de uma aresta $uv$ de nível $i$ da floresta $F_i$ quebra uma componente de $F_i$ em duas, $T_u$ e $T_v$. Sendo $T_u$ a menor das duas, a rotina \texttt{substituaAresta} realiza o rebaixamento das arestas de nível $i$ de $T_u$ para $i-1$. Para fazer isso de forma eficiente, introduzimos um método auxiliar chamado \texttt{procureArestaDeNível}. Esse método utiliza o atributo \textit{arestasDeNível} para encontrar um a um, numa árvore da floresta $F_i$, os nós de arestas de nível $i$.

\begin{programruledcaption}{\texttt{procureArestaDeNível($p$)} \label{prog:findEdgesIsLevel-GD}}
    \noindent\textbf{Entrada}: Recebe um nó $p$ de uma floresta com o contador \textit{arestasDeNível} $> 0$.
    \\
    \noindent\textbf{Saída}: Devolve um nó de aresta da subárvore do nó com \textit{éNível} verdadeiro.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \textbf{se} p.éNível \textbf{então}
        retorne p
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{e} p.esq.arestasDeNível > 0 \textbf{então}
        retorne \texttt{procureArestaDeNível($\emph{p.esq}$)}
    \textbf{senão}
        retorne \texttt{procureArestaDeNível($\emph{p.dir}$)}
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

Veja que o Programa~\ref{prog:findEdgesIsLevel-GD} não altera o grafo, e, portanto, as invariantes são preservadas. Como a Euler tour tree é balanceada, então o consumo de tempo de cada percurso é $\Oh(\lg n)$ (amortizado em nossa implementação, onde sempre realizamos um \texttt{splay} no nó devolvido). Assim, se temos $k$ arestas de nível $i$ da árvore a serem rebaixadas, então a busca por essas $k$ arestas custará tempo $\Oh(k \lg n)$.

A rotina \texttt{procureArestaDeNível} será usada na rotina \texttt{substituaAresta}, que será descrita na Seção~\ref{sec:replace-edge}.

\subsection{Nó de vértice}
\label{sec:node-vertex}

Na rotina \texttt{substituaAresta}, para percorrermos as arestas reserva de nível $i$ incidentes a vértices da árvore $T_u$ em busca de uma aresta substituta, cada nó da floresta $F_i$ possui um booleano chamado \textit{incideArestaReservaDeNível}, que é verdadeiro somente se o nó é um nó de vértice, e o vértice em questão é ponta de alguma aresta reserva de nível $i$. Dessa forma, se $uv$ é aresta reserva de nível~$2$, então os nós de vértice de $u$ e de $v$ em $F_2$ terão o atributo \textit{incideArestaReservaDeNível} como verdadeiro. 

Cada nó das florestas também guardará um contador \textit{arestasReservasDeNível}, que armazena a quantidade de nós em sua subárvore com o atributo \textit{incideArestaReservaDeNível} verdadeiro. Esse contador deve ser mantido atualizado quando é feita qualquer alteração em uma das árvores binárias que representam as florestas. Na nossa implementação, a atualização é feita na operação \texttt{splay}, sempre que essa executa uma rotação. 

O campo \textit{incideArestaReservaDeNível} de um nó de vértice $u$ pode mudar de valor quando houver inserções e remoções de arestas reserva que possuem como uma da suas pontas o vértice $u$. Portanto, mostraremos dois métodos, \texttt{incrementeArestasReservasDeNível} e \texttt{decrementeArestasReservasDeNível}, que modificam este campo e atualizam o contador \textit{arestasReservasDeNível} chamando \texttt{atualizeArestasReservasDeNível}, descrito no Programa~\ref{prog:updateReserveEdgesCount-GD} abaixo.  

O método \texttt{decrementeArestasReservasDeNível} do Programa~\ref{prog:decrementReserveEdgesCount-GD} atualiza o campo \textit{incideArestaReservaDeNível} de um nó de vértice $u$ para falso quando ele não tem mais elementos em sua lista de adjacências das arestas reserva, isto é, quando não há mais nenhuma aresta reserva do nível da floresta incidente nele. A assinatura \texttt{R[u]} retorna o conjunto de vizinhos da lista de adjacências de $u$.

\begin{programruledcaption}{\texttt{decrementeArestasReservasDeNível($F$, $R$, $u$)} \label{prog:decrementReserveEdgesCount-GD}}
    \noindent\textbf{Entrada}: Recebe um vértice $u$ da floresta $F$ e uma lista de adjacências $R$.\\
    \noindent\textbf{Efeito}: Atualiza o campo \textit{incideArestaReservaDeNível} para falso se necessário.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
        ]
        vérticeU := F.nó[u, u]
        \textbf{se} R[u] = $\emptyset$ \textbf{então}
            \texttt{splay($\emph{vérticeU}$)} 
            vérticeU.incideArestaReservaDeNível := falso
            \texttt{atualizeArestaReservaDeNível($\emph{vérticeU}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Já o método \texttt{incrementeArestasReservasDeNível} do Programa~\ref{prog:incrementReserveEdgesCount-GD} atualiza o atributo \textit{incideArestaReservaDeNível} de um nó de vértice $u$ para verdadeiro quando adicionamos um vértice $v$ na lista de adjacências de $u$ e $v$ é o primeiro elemento de sua lista de adjacências, pois isso indica que $u$ passa a ser incidente à aresta reserva $uv$.

\begin{programruledcaption}{\texttt{incrementeArestasReservasDeNível($F$, $R$, $u$)} \label{prog:incrementReserveEdgesCount-GD}}
    \noindent\textbf{Entrada}: Recebe um vértice $u$ da floresta $F$ e uma lista de adjacências $R$.\\
    \noindent\textbf{Efeito}: Atualiza o campo \textit{incideArestaReservaDeNível} para verdadeiro se necessário.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    vérticeU := F.nó[u, u]
    \textbf{se} |R[u]| = $1$ \textbf{então}
        \texttt{splay($\emph{vérticeU}$)}
        vérticeU.incideArestaReservaDeNível := verdadeiro
        \texttt{atualizeArestaReservaDeNível($\emph{vérticeU}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption} 

\begin{programruledcaption}{\texttt{atualizeArestasReservasDeNível($p$)} \label{prog:updateReserveEdgesCount-GD}}
    \noindent\textbf{Entrada}: Recebe um nó $p$.
    \\
    \noindent\textbf{Efeito}: Atualiza o contador \textit{arestasReservasDeNível} de $p$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    c := 0
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{então}
        c := c + p.esq.arestasReservasDeNível
    \textbf{se} p.dir $\neq$ \texttt{NIL} \textbf{então}
        c := c + p.dir.arestasReservasDeNível
    \textbf{se} p.incideArestaReservaDeNível  \textbf{então}
        c := c + 1
    p.arestasReservasDeNível := c
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

O Programa~\ref{prog:updateReserveEdgesCount-GD} consome tempo $\Oh(1)$. Já os Programas~\ref{prog:decrementReserveEdgesCount-GD} e \ref{prog:incrementReserveEdgesCount-GD} consomem tempo $\Oh(\lg n)$, amortizado em nossa implementação por conta das operações \texttt{splay}. Como estes três métodos não alteram a floresta $F_i$, alteram apenas uma da árvores uma das árvores binárias que a representam, então as três invariantes são preservadas. 

Usando o mesmo exemplo da Figura~\ref{fig:euler-tour-balanced-tree} na Seção~\ref{sec:euler-tour-trees}, podemos ilustrar como estaria o atributo \textit{arestasReservasDeNível} de cada nó na árvore.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node, label=below:{5}] (ad) at (0, 0) {$ad$};
        \node[node, label=below:{3}] (ab) at (-4.5, -1.5) {$ab$};
        \node[node, label=below:{2}] (cd) at (4.5, -1.5) {$cd$};
        \node[node, label=below:{2}] (dc) at (3, -3) {$dc$};
        \node[node, fill=green!30, label=below:{1}] (dd) at (1.5, -4.5) {$dd$};
        \node[node, fill=green!30, label=below:{1}] (cc) at (4.5, -4.5) {$cc$};
        
        
        \node[node, label=below:{0}] (da) at (6, -3) {$da$};
        \node[node, label=below:{0}] (ae) at (7.5, -4.5) {$ae$};
        
        
        \node[node, label=below:{2}] (ea) at (-6, -3) {$ea$};
        \node[node, fill=green!30, label=below:{1}] (ee) at (-7.5, -4.5) {$ee$};
        \node[node, fill=green!30, label=below:{1}] (aa) at (-4.5, -4.5) {$aa$};


        \node[node, fill=green!30, label=below:{1}] (bb) at (-3, -3) {$bb$};
        \node[node, label=below:{0}] (ba) at (-1.5, -4.5) {$ba$};

        

        % tree edges (normal black edges)
        \draw[edge] (ad) -- (ab) node[midway, below] {};
        \draw[edge] (ad) -- (cd) node[midway, below] {};
        \draw[edge] (cd) -- (dc) node[midway, below] {};
        \draw[edge] (cd) -- (da) node[midway, below] {};
        \draw[edge] (bb) -- (ba) node[midway, below] {};
        \draw[edge] (ea) -- (ee) node[midway, below] {};
        \draw[edge] (ea) -- (aa) node[midway, below] {};
        \draw[edge] (dc) -- (dd) node[midway, below] {};
        \draw[edge] (dc) -- (cc) node[midway, below] {};
        \draw[edge] (da) -- (ae) node[midway, below] {};

        \draw[edge] (ab) -- (ea) node[midway, below] {};
        \draw[edge] (ab) -- (bb) node[midway, below] {};


    \end{tikzpicture}
    \caption{Árvore de uma das componentes da floresta $F_i$, onde nós pintados em verde indicam nós de vértices com o atributo incideArestaReservaDeNível verdadeiro. No nosso exemplo, todos os vértices são ponta de alguma aresta reserva de nível $i$. Embaixo de cada nó temos o contador arestasReservasDeNível.}
    \label{fig:euler-tour-balanced-tree-reserve-edges-propagation}
\end{figure}

\raggedbottom
 
No \texttt{substituaAresta} acionado na floresta $F_i$, após rebaixarmos as arestas de nível $i$ de~$T_u$, precisamos procurar por uma aresta substituta. Para isso, precisamos buscar por uma aresta reserva de nível $i$, com uma ponta em $T_u$ e outra em $T_v$, para que consigamos reconectar as duas componentes de $F_i$ separadas pela remoção de $uv$. 

Para resolver este problema de maneira eficiente, usa-se uma estratégia semelhante à que usamos para buscar arestas de nível $i$ em $T_u$. Introduzimos um método auxiliar chamado \texttt{procureNóIncideArestaReservaDeNível}, que devolveria um vértice de $T_u$ que incide em alguma aresta reserva de nível $i$. Assim, podemos percorrer cada vizinho desse vértice em $R_i$ para verificar se a aresta entre eles liga $T_u$ a $T_v$. 

\begin{programruledcaption}{\texttt{procureNóIncideArestaReservaDeNível($p$)} \label{prog:findReserveEdge-GD}}
    \noindent\textbf{Entrada}: Recebe um nó da floresta $p$ com o contador \textit{arestasReservasDeNível} $> 0$.
    \\
    \noindent\textbf{Saída}: Devolve um nó de vértice da subárvore de $p$ com \textit{incideArestaReservaDeNível} verdadeiro.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \textbf{se} p.incideArestaReservaDeNível \textbf{então}
        retorne p
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{e} p.esq.arestasReservasDeNível > 0 \textbf{então}
        retorne \texttt{procureNóIncideArestaReservaDeNível($\emph{p.esq}$)}
    \textbf{senão}
        retorne \texttt{procureNóIncideArestaReservaDeNível($\emph{p.dir}$)}
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

Veja que o Programa~\ref{prog:findReserveEdge-GD} não altera o grafo, e, portanto, as invariantes são preservadas. Como a Euler tour tree é balanceada, o consumo de tempo do Programa~\ref{prog:findReserveEdge-GD} é $\Oh(\lg n)$ (amortizado em nossa implementação, que sempre aciona a rotina \texttt{splay} no nó devolvido).

A rotina \texttt{procureNóIncideArestaReservaDeNível} será usada na rotina \texttt{substituaAresta}, que será descrita na Seção~\ref{sec:replace-edge}.

\subsection{Versão completa da rotina de adição de arestas}
\label{sec:code-edge-addition-second-version}

Nesta seção, apresentamos uma versão completa da rotina \texttt{adicioneGD} mostrada na Seção~\ref{prog:addGD}, para incorporar os atributos descritos nas seções anteriores.

\begin{programruledcaption}{\texttt{adicioneGD($G$, $u$, $v$)} \label{prog:addGD-version2}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, com $u < v$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := $L$
    \textbf{se} \texttt{conectadosFD($G.F_{L}$, $u$, $v$)} \textbf{então} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{adicioneLA($G.R_{L}$, $u$, $v$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $v$)}
    \textbf{senão}
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
        \texttt{atualizeÉNível($G.F_L$, $u$, $v$, $\textbf{verdadeiro}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Nesta versão final, veja que as linhas $5$ e $6$ são necessárias para que o campo \textit{incideArestaReservaDeNível}, assim como o campo de todos os nós da floresta dos vértices $u$ e $v$ estejam corretos. Já a linha $9$ define o atributo \textit{éNível} do nó de aresta $uv$ como verdadeiro em $F_L$, quando ela é aresta da floresta, e atualiza o campo \textit{arestasDeNível} de todos os nós da floresta.

Atualizamos os atributos desses nós que descrevemos para fazermos a remoção eficiente de arestas, cuja rotina será descrita também com ajustes na Seção~\ref{sec:code-edge-removal-second-version}. Note que o método \texttt{adicioneGD} do Programa~\ref{prog:addGD-version2} continua tendo o mesmo consumo de tempo do Programa~\ref{prog:addGD} após esses ajustes, ou seja, $\Oh(\lg n)$ amortizado. 

\subsection{Versão completa da rotina de remoção de arestas}
\label{sec:code-edge-removal-second-version}

Nessa seção, apresentamos uma versão completa da rotina \texttt{removaGD} apresentada no Programa~\ref{prog:removeGD}, incorporando os atributos descritos na Seção~\ref{sec:node-vertex}. 

\begin{programruledcaption}{\texttt{removaGD($G$, $u$, $v$)} \label{prog:removeGD-version2}}
    \noindent\textbf{Entrada}: Recebe dois vértices adjacentes $u$ e $v$ do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    i := $\dotvarm{G}{nível}{u,v}$
    $\dotvarm{G}{nível}{u,v}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        \textbf{para} j := i \textbf{até} L \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaAresta($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLA($G.R_i$, $u$, $v$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $u$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

A diferença entre as duas versões de \texttt{removaGD} é que a segunda tem as linhas $10$ e $11$ a mais. Tais linhas são necessárias para que o campo \textit{incideArestaReservaDeNível} e o contador \textit{arestasReservasDeNível} dos nós estejam corretos, visto que, ao remover uma aresta reserva, precisamos verificar se os vértices incidentes a ela ainda são incidentes a alguma outra aresta reserva de $R$.  

Agora falta descrever a rotina \texttt{substituaAresta}. Da mesma forma que a primeira versão, nesta segunda versão \texttt{removaGD} também consumirá tempo amortizado $\Oh(\lg^2 n)$ mais o custo do \texttt{substituaAresta}.

\subsection{Rotina de substituição de aresta}
\label{sec:replace-edge}

A rotina de substituição da aresta \texttt{substituaAresta} está descrita no Programa~\ref{prog:replaceGD} abaixo, onde usaremos vários dos métodos auxiliares apresentados nas Seções~\ref{sec:node-edge} e~\ref{sec:node-vertex}. Além disso, usaremos dois métodos auxiliares chamados \texttt{rebaixeNívelDaAresta} e \texttt{testeSubstituta}, que serão explicados de maneira detalhada no momento em que estivermos explicando cada trecho do código de \texttt{substituaAresta}. O atributo \textit{tam}, que existe em todos os nós da floresta, guarda o número de nós na subárvore de cada nó.

\begin{programruledcaption}{\texttt{substituaAresta($G$, $i$, $u$, $v$)} \label{prog:replaceGD}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, e o nível $i$ da aresta $uv$. \\
    \noindent\textbf{Efeito}: Adiciona uma aresta substituta no grafo, se ela existir.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    \textbf{para} j := i \textbf{até} $L$ \textbf{faça}
        $T_u$ := \texttt{splay($G.F_j.\emph{nó}[u, u]$)}  (*@\hfill $\triangleright$ torna o nó $uu$ raiz de $T_u$@*)
        $T_v$ := \texttt{splay($G.F_j.\emph{nó}[v, v]$)}  (*@\hfill $\triangleright$ torna o nó $vv$ raiz de $T_v$@*)    
        \textbf{se} $T_u$.tam > $T_v$.tam \textbf{então}
            $T_u \leftrightarrow T_v$
        \textbf{enquanto} $T_u$.arestasDeNível > 0 \textbf{faça} 
            nóXY := \texttt{procureArestaDeNível($T_u$)}
            $T_u$ := \texttt{splay($\emph{nóXY}$)}
            \texttt{rebaixeNívelDaAresta($G$, $\emph{nóXY}$, j)}
        \textbf{enquanto} $T_u$.arestasReservasDeNível > 0     \textbf{faça}
            nóXX := \texttt{procureNóIncideArestaReservaDeNível($T_u$)}
            $T_u$ := \texttt{splay($\emph{nóXX}$)}
            ($x$, $x$) := \textit{nóXX.vértices}
            \textbf{para} $y \in G.R_j[x]$ \textbf{faça}
                se \texttt{testeSubstituta($G$, $x$, $y$, $j$)} \textbf{então} 
                    \textbf{retorne}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Para explicar o \texttt{substituaAresta} do Programa~\ref{prog:replaceGD}, descreveremos a função de cada trecho do código. Vamos assumir de início que estamos aplicando as operações de remoção em um grafo $G$ de $n$ vértices. Lembre-se que, ao removermos uma aresta $uv$ da floresta de nível $i$, precisamos procurar uma substituta partindo de $R_i$, e se não encontrarmos, passamos a buscar em $R_{i + 1}, \ldots, R_L$. A linha $2$ faz exatamente essa iteração sobre os níveis $i$ até $L$. Suponha que estamos na iteração $j$ da linha $2$, ou seja, já removemos $uv$ de $F_i, \ldots, F_{j-1}$ e não encontramos aresta substituta em $R_i, \ldots, R_{j-1}$.

Nas linhas $3$ e $4$, obtemos as árvores $T_u$ e $T_v$, que foram derivadas da floresta $F_j$, já que uma componente desta foi quebrada em duas após a remoção de $uv$. As operações \texttt{splay} puxam os nós $u$ e $v$ para raiz de $T_u$ e $T_v$, respectivamente. As linhas $5$ e $6$ garantem que $|T_u| \leq |T_v|$ como já discutido na Seção~\ref{sec:dynamic-graph-edge-removal}. 

Nas linhas $7$ a $10$, realizamos o processo de rebaixar as arestas de $T_u$ de nível $j$. Na linha $7$, temos um laço que terminará quando todas as arestas de nível $j$ tiverem sido rebaixadas, isto é, quando o contador \textit{arestasDeNível} do nó raiz de $T_u$ estiver nulo. Na linha $8$, utilizamos o método auxiliar \texttt{procureArestaDeNível}, que retornará um nó de aresta de nível $j$, ou seja, que possui o \textit{éNível} verdadeiro. Para cada nó de aresta retornado, acionamos \texttt{splay} nele e atualizamos $T_u$. Em seguida, o rebaixamos chamando o método \texttt{rebaixeNívelDaAresta}, descrito abaixo.

\begin{programruledcaption}{\texttt{rebaixeNívelDaAresta($G$, $p$, $j$)} \label{prog:decrease-edge-level}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$, um nó de aresta $p$ da floresta $F_j$ que é raiz de uma árvore e tem nível $j$.\\
    \textbf{Efeito}: Rebaixa o nível do nó de aresta $p$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    ($x$, $y$) := \textit{p.vértices}
    $\dotvarm{G}{nível}{x, y}$ := j - 1
    \texttt{atualizeÉNível($G.F_{j}$, $x$, $y$, \textbf{falso})}
    \texttt{adicioneFD($G.F_{j-1}$, $x$, $y$)}
    \texttt{atualizeÉNível($G.F_{j - 1}$, $x$, $y$, \textbf{verdadeiro})}

    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

No Programa~\ref{prog:decrease-edge-level}, atualizamos o nível do nó de aresta $xy$ de $j$ para $j-1$. Note que o nó $p$ é raiz de sua árvore pois foi feito um splay neste nó antes da chamada a \texttt{rebaixeNívelDaAresta}, na linha $9$ do Programa~\ref{prog:replaceGD}. Ademais, como rebaixamos $xy$ de $F_j$ para $F_{j - 1}$, então em $F_j$ atualizamos o seu atributo \textit{éNível} para falso, e em $F_{j-1}$ atualizamos este atributo para verdadeiro. Veja que \texttt{rebaixeNívelDaAresta} consome tempo amortizado $O(\lg n)$.

Voltando ao Programa~\ref{prog:replaceGD}, nas linhas $11$ a $17$, procuramos por uma aresta substituta de nível~$j$. Similarmente à linha $7$, a linha $11$ é um laço que terminará quando não existirem mais arestas reserva de nível $j$ (ou seja, quando o contador \textit{arestasReservasDeNível} do nó raiz de $T_u$ estiver nulo) ou quando achamos uma aresta substituta.  

Na linha $12$, acionamos \texttt{procureNóIncideArestaReservaDeNível}, que retornará um nó de vértice $xx$ que incide em alguma aresta reserva de nível~$j$. Depois, acionamos \texttt{splay} em $xx$ e atualizamos $T_u$. Na linha $14$, obtemos o vértice $x$ do nó $xx$ e percorremos todos os vizinhos $y$ de $x$ na lista de adjacências na linha $15$, pois queremos testar se $xy$ é uma aresta substituta.

Para isso, chamamos o método auxiliar \texttt{testeSubstituta} na linha $16$, descrito no Programa~\ref{prog:find-substitute}. Como o nome sugere, o método testa se $xy$ é uma aresta substituta, devolvendo verdadeiro se $xy$ for e falso caso contrário. Quando o método devolve verdadeiro, chegamos à linha $17$ do Programa~\ref{prog:replaceGD}, terminando o algoritmo. Caso contrário, continuamos percorrendo os vizinhos $y$ da lista de adjacências de $x$ e chamando o mesmo método várias vezes.

\begin{programruledcaption}{\texttt{testeSubstituta($G$, $x$, $y$, $j$)} \label{prog:find-substitute}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$, as pontas $x$ e $y$ do nó $xy$ e o nível $j$.\\
    \textbf{Saída}: Devolve verdadeiro se a aresta $xy$ é substituta e falso caso contrário.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \texttt{removaLA($G.R_j$, $x$, $y$)} 
    \textbf{se} \texttt{conectadosGD($G$, $x$, $y$)} \textbf{então} (*@\hfill $\triangleright$ a aresta xy não é substituta@*)
        $\dotvarm{G}{nível}{x, y}$ := j - 1
        \texttt{adicioneLA($G.R_{j-1}$, $x$, $y$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{j-1}$, $G.R_{j-1}$, $x$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{j-1}$, $G.R_{j-1}$, $y$)}
        \textbf{retorne falso}
    \textbf{senão} (*@\hfill $\triangleright$ a aresta xy é substituta@*)
        L := $\dotvar{G}{nívelMax}$
        \textbf{para} k := j \textbf{até} $L$ \textbf{faça}
            \texttt{adicioneFD($G.F_k$, $x$, $y$)}
        \textbf{se} x > y \textbf{então}
            x $\leftrightarrow$ y
        \texttt{atualizeÉNível($G.F_j$, $x$, $y$, $\textbf{verdadeiro}$)}
        \textbf{retorne verdadeiro}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

No Programa~\ref{prog:find-substitute}, a linha $1$ remove a aresta reserva $xy$ de $R_j$, independentemente se tal aresta é substituta ou não, pois ou ela será rebaixada, ou será uma aresta substituta, que será incluída em $F_j$. Se $xy$ não é substituta, então ela é rebaixada para $R_{j-1}$, como visto na Seção~\ref{sec:dynamic-graph-edge-removal}. Se ela é substituta, então se tornará uma aresta da floresta de nível~$j$ conectando $T_u$ a $T_v$.

As linhas $2$ a $7$ englobam o caso em que os vértices $x$ e $y$ estão em $T_u$, isto é, quando \texttt{conectadosGD(G, x, y)} retorna verdadeiro. Isso quer dizer que $xy$ não é uma aresta substituta, e por isso precisamos rebaixá-la de $R_j$ para $R_{j-1}$, além de atualizar os atributos dos nós de vértice $x$ e $y$ em $F_{j-1}$ ao acionar \texttt{incrementeArestasReservasDeNível}. Devolvemos falso porque, neste caso, $xy$ não é aresta substituta.

Veja que~\texttt{conectadosGD(G, x, y)} só devolverá falso quando $x$ está em $T_u$ e $y$ está em $T_v$, pois assim os dois vértices estariam em componentes separadas da floresta $F_j$. Este caso, abordado nas linhas $8$ a $15$ do Programa~\ref{prog:find-substitute}, mostra que encontramos $xy$ como uma aresta substituta, e finalizamos o algoritmo incluindo $xy$ em todas as florestas $F_k$, para $k = j, \ldots, L$, para manter a invariante~\ref{invariant2}. Além disso, se a aresta substituta encontrada é de nível $j$, precisamos atualizar o atributo \textit{éNível} do nó desta aresta em $F_j$ para verdadeiro quando a adicionamos na floresta $F_j$, como acontece na linha $14$. Por fim, devolvemos verdadeiro pois, neste caso, achamos uma aresta substituta. 

Veja que, no Programa~\ref{prog:find-substitute}, as linhas $2$ a $7$ possuem custo amortizado $\Oh(\lg n)$. Isso quer dizer que, enquanto as arestas que estamos testando não forem substitutas, o método \texttt{testeSubstituta} será acionado várias vezes com esse custo de tempo. No momento em que encontrarmos uma substituta, \texttt{testeSubstituta} será acionado uma única vez e consumirá tempo amortizado $\Oh(\lg^2 n)$ por causa das linhas 10 e 11, e assim o algoritmo será finalizado. 

Agora, explicaremos o custo da rotina \texttt{substituaAresta}. No pior caso, uma execução desta rotina pode consumir muito tempo. Por exemplo, se o grafo já está com $m = \Theta(n^2)$ arestas inseridas, todas de nível $L$, pode ocorrer uma remoção que aciona o \texttt{substituaAresta} e que acarreta o rebaixamento de $\Theta(n^2)$ arestas, a um custo $\Omega(n^2 \lg n)$. 

No entanto, para chegar a essa situação, teriam ocorrido $\Theta(n^2)$ inserções, cada uma com um custo bem mais barato, de $\Oh(\lg n)$. Isso sugere que possivelmente uma análise amortizada do custo das operações leve a um custo por operação mais baixo.

Agora mostraremos que, se ocorreram $t$ operações de inserção e remoção de arestas desde a criação do grafo, então o custo total de tal sequência de operações é $\Oh(t \lg^2 n)$, o que resulta em um custo amortizado por operação de $\Oh(\lg^2 n)$.

Para tanto, cada inserção será responsável não apenas pelo custo da inserção de uma aresta $e$, mas também pelo custo de todos os rebaixamentos sofridos por $e$ no decorrer de todas as remoções que ocorrerem após a inserção de $e$.
Isso quer dizer que a inserção da aresta $e$ vai pagar por cada execução das linhas $7$ a $10$ do Programa~\ref{prog:replaceGD} e das linhas $2$ a $7$ do Programa~\ref{prog:find-substitute} que processa a aresta $e$. Como a inserção custa $\Oh(\lg n)$ e essas linhas custam $\Oh(\lg n)$ e são executadas $\Oh(\lg n)$ vezes, pois $e$ pode ser rebaixada no máximo $\left\lceil \lg n \right\rceil$ vezes, o custo pago por uma inserção é $\Oh(\lg^2 n)$.

Já uma remoção de aresta, executada pelo Programa~\ref{prog:removeGD-version2}, custa $\Oh(\lg^2 n)$ mais o custo do \texttt{substituaAresta}. O custo do \texttt{substituaAresta} é $\Oh(\lg^2 n)$ excluindo-se as execuções das linhas $7$ a $10$ do Programa~\ref{prog:replaceGD}, como também as linhas $2$ a $7$ do Programa~\ref{prog:find-substitute}. Isso porque, desconsiderando estas linhas onde ocorrem rebaixamento de aresta, na linha $2$ do Programa~\ref{prog:replaceGD} acaba tendo custo $\Oh(\lg n)$ nas linhas restantes. Apesar de as linhas $10$ e $11$ do Programa~\ref{prog:find-substitute} consumirem tempo $\Oh(\lg^2 n)$, este trecho do código será executado uma única vez quando encontrarmos a substituta e o algoritmo será finalizado. Assim, como a linha $2$ pode ser executada em no máximo $\Oh(\lg n)$ vezes, temos que \texttt{substituaAresta} consome tempo amortizado $\Oh(\lg^2 n)$ por operação de remoção.

Com isso, concluímos que o custo total da sequência de $t$ inserções e remoções é $\Oh(t \lg^2 n)$, e assim cada inserção e remoção consome tempo amortizado $\Oh(\lg^2 n)$.