%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Algoritmo para MSF decremental}

\enlargethispage{.8\baselineskip}

Neste capítulo, estudaremos o problema da árvore geradora mínima em grafos dinâmicos. 
Dado um grafo conexo $G$ com um custo associado a cada uma de suas arestas, 
o problema da árvore geradora mínima consiste em determinar uma árvore geradora
de G com custo mínimo, onde o custo de uma árvore é a soma dos custos de suas arestas. 
Como estamos interessados em grafos dinâmicos, é natural remover a restrição de que o 
grafo seja conexo, e neste caso considerar florestas geradoras maximais de custo mínimo 
(MSF, do inglês \emph{minimum spanning forest}). Chamamos um grafo com um custo 
associado a cada aresta de \textbf{grafo ponderado}. 

O problema da árvore geradora mínima em grafos ponderados (conexos) estáticos pode ser 
resolvido eficientemente, por exemplo, pelos algoritmos de Kruskal e de Prim. O algoritmo de Kruskal 
utiliza uma estrutura de dados clássica conhecida como union-find, enquanto que o algoritmo
de Prim utiliza uma fila de prioridades. Não há na literatura uma versão destes algoritmos 
para grafos dinâmicos. Isso talvez se deva à característica essencialmente sequencial destes
algoritmos, que modificam suas estruturas internas conduzidos por uma ordem de eventos.
Uma alteração no grafo poderia levar a uma alteração em toda a sequência de eventos 
nesses algoritmos a partir de um certo ponto, e com isso não há uma versão eficiente deles
que acomode alterações no grafo. 

Por outro lado, Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propuseram uma adaptação do seu algoritmo para conexidade em 
grafos dinâmicos, apresentado no Capítulo 2, para que este mantenha, de maneira eficiente, 
uma floresta geradora maximal de custo mínimo em um grafo ponderado que pode sofrer 
remoções de arestas.  Ou seja, eles propuseram um algoritmo que resolve de maneira 
eficiente o problema que chamamos de MSF decremental.  Neste capítulo, descreveremos
esse algoritmo, que é uma adaptação do algoritmo descrito no Capítulo 2 para que este 
passe a resolver o problema da MSF decremental.  

\section{Biblioteca da MSF decremental}
\label{sec:decremental-msf-library}

Implementar o algoritmo decremental para florestas geradoras maximais de custo mínimo (MSF, de \textit{Minimum Spanning Forest}) resume-se à construção da seguinte biblioteca de forma eficiente:

\begin{itemize}
    \item \texttt{\textbf{MSFDecremental(n, E)}}: contrói e devolve um grafo ponderado $G$ com $n$ vértices e as arestas ponderadas dadas no conjunto $E$;
    \item \texttt{\textbf{extraiaPesoMSF(G)}}: devolve o peso da MSF do grafo ponderado $G$;
    \item \texttt{\textbf{removaMSF(G, u, v)}}: remove a aresta $uv$ do grafo ponderado $G$.
\end{itemize} 

Note que, diferente da biblioteca do algoritmo de conexidade em grafos dinâmicos, apresentada na Seção~\ref{sec:dynamic-graph-routines}, na MSF decremental não temos um método equivalente a \texttt{adicioneGD} disponível para o usuário. Em nossa implementação \cite{chung2025}, para criarmos um grafo $G$ de $n$ vértices e $m$ arestas ponderadas dadas em $E$, acionamos~ \texttt{MSFDecremental($n$,~$E$)}, onde criamos $\left\lceil \lg n \right\rceil$ florestas e $\left\lceil \lg n \right\rceil$ listas de adjacências com $n$ vértices isolados. Em seguida, ordenamos e inserimos essas $m$ arestas em ordem crescente de peso, usando uma biblioteca pronta do $\emph{C++}$ para ordená-las, que consome tempo esperado $\Oh(n \lg n)$. Estas $m$ arestas são  inseridas uma a uma acionando uma rotina que chamamos de  \texttt{adicioneMSF(u, v, w)}, onde $u$ e $v$ são pontas da aresta e $w$ é o peso dela.

A rotina \texttt{adicioneMSF} é acionada somente dentro do construtor. Por ser uma rotina privada, ou seja, não está disponível para o usuário, após a inserção destas arestas, não é permitido mais operações de inserção, somente de remoção de arestas. Para o usuário, então, só estarão disponíveis as rotinas \texttt{custoMSF} e \texttt{removaMSF}. A versão totalmente dinâmica, que inclui a rotina \texttt{adicioneMSF} para o usuário, será estudada posteriormente no Capítulo~\ref{chapter:fully-MSF}.

O construtor \texttt{MSFDecremental}, devido à ordenação de arestas, possui consumo de tempo $\Oh(n \lg n)$. Já a rotina \texttt{custoMSF} possui consumo de tempo $\Oh(1)$. Como estes dois métodos são mais simples, passaremos brevemente sobre eles, e detalharemos mais a rotina \texttt{removaMSF}, que possui a rotina auxiliar \texttt{substituaArestaMSF} implementada de maneira diferente do \texttt{substituaAresta} do algoritmo de conexidade em grafos dinâmicos. 

Usaremos várias definições já apresentadas no algoritmo de conexidade dinâmica em grafos dinâmicos, incluindo as mesmas invariantes apresentadas na Seção~\ref{sec:level-slicing}, os mesmos tipos de arestas da Seção~\ref{sec:dynamic-graph-edge-types} e nós das florestas apresentados na Seção~\ref{sec:graph-nodes}. A seguir, apresentaremos as rotinas da MSF decremental e alguns ajustes a serem feitos. 

\subsection{Listas de adjacências}
\label{sec:adjancency-lists-min-heap}

Na Seção~\ref{sec:dynamic-graph-edge-types}, apresentamos a biblioteca de \texttt{listasDeAdjacências}, onde usamos um mapa hash para inserir ou remover um vértice $v$ da lista de $u$, além de percorrer os vizinhos da lista de $u$. No algoritmo da MSF decremental, quando removemos uma aresta de nível $i$ da floresta $F_i$, uma componente desta será quebrada em duas, $T_u$ e $T_v$, da mesma forma que no algoritmo de conexidade em grafos dinâmicos. A diferença é que, no caso da MSF decremental, precisamos buscar por uma aresta substituta que tenha o menor peso e que ligue $T_u$ a~$T_v$. Não podemos simplesmente percorrer todos os vizinhos $y$ de cada vértice $x$ em $T_u$, verificar se $xy$ reconecta as componentes separadas e se é de menor peso dentre todas as substitutas, já que isso seria ineficiente.

Assim, fica claro que seria bom percorrer as arestas reservas em ordem crescente de peso e testar se alguma é substituta nesta ordem. Por isso, em vez de usar um mapa hash para armazenar os vizinhos de cada vértice, usaremos um min-heap. Na verdade, como estamos trabalhando com nós de vértice e de aresta, cada nó de vértice $u$ guardará um min-heap com os vizinhos de $u$ em $R_i$, onde a chave dessa estrutura de dados para um vizinho $v$ será o peso da aresta $uv$. Nós de aresta também guardarão um min-heap, porém vazio. 

Os métodos principais (remoção, inserção e extração da chave mínima) que usamos no min-heap consomem tempo O($\lg n)$ usando uma implementação tradicional de heap, como a descrita no Capítulo 6 de Thomas H. Cormen et al. \cite{clrs}. O resto dos métodos consomem tempo constante, e eles serão necessários para buscar a aresta substituta de peso mínimo, como descreveremos mais à frente.

Como o min-heap é uma estrutura de dados bastante conhecida, não iremos descrever a sua implementação em detalhes. O objetivo é ressaltar as diferenças entre as listas de adjacências utilizadas no algoritmo de conexidade em grafos dinâmicos e na MSF decremental, e como essa mudança afetará o comportamento do método \texttt{substituaArestaMSF} da MSF decremental.

Assim, com base na implementação clássica do min-heap, podemos definir a biblioteca das listas de adjacências da MSF decremental. 

\begin{itemize}
    \item \texttt{\textbf{listasDeAdjacênciasMSF(n)}}: constrói e devolve um grafo com $n$ vértices e sem arestas, representado por listas de adjacências;
    \item \texttt{\textbf{adicioneLAMSF(R, u, v, w)}}: adiciona o vértice $u$ na lista de adjacências de $v$ em $R$ e vice-versa, considerando que o peso de $uv$ é $w$;
    \item \texttt{\textbf{removaLAMSF(R, u, v)}}: remove o vértice $u$ da lista de adjacências de $v$ em $R$ e vice-versa.
    
    \item \texttt{\textbf{extraiaMinLAMSF(R, u)}}: remove e retorna o par $\{v, p\}$, onde $v$ é vértice do min-heap de $u$ em $R$ com chave mínima $w$.
\end{itemize} 

Uma chamada à rotina \texttt{adicioneLAMSF(R, u, v, w)} adiciona o par $\{u, p\}$ no min-heap de $v$, como também adiciona o par $\{v, p\}$ no min-heap de $u$, consumindo tempo $\Oh(\lg n)$. Similarmente, uma chamada à rotina \texttt{removaLAMSF(R, u, v)} remove o par $\{u, p\}$ do min-heap de $v$, como também remove o par $\{v, p\}$ do min-heap de $u$, consumindo também tempo $\Oh(\lg n)$. 

O método \texttt{extraiaMinLAMSF} também consome tempo $\Oh(\lg n)$, já que estamos extraindo a chave mínima do min-heap de um vértice. Ele será utilizado quando descrevermos o método \texttt{substituaArestaMSF}.

\section{Ajustes nas invariantes}

Como agora estamos tratando de florestas geradoras maximais de custo mínimo (MSFs), ajustaremos somente a primeira invariante, onde substituímos o termo floresta maximal por MSF, como se pode ver abaixo.

\begin{enumerate}[label=(\Roman*)]
    \item \label{invariant11} $F_i$ é uma MSF de $G_i$ para todo $1 \leq i \leq  \left\lceil \lg n \right\rceil$;
    
    \item \label{invariant22} $F_i \subseteq F_{i+1}$ para todo $1 \leq i \leq \left\lceil \lg n \right\rceil - 1$;
    
    \item \label{invariant33} Cada componente da floresta $F_i$ possui no máximo $2^i$ vértices.
\end{enumerate}

Assim, a partir deste momento, usaremos estas três invariantes e mostraremos como elas são preservadas no decorrer das modificações no grafo.

\section{Rotinas da biblioteca da MSF decremental}

\subsection{Criação do grafo}

O construtor \texttt{MSFDecremental} é bem parecido com o do grafo dinâmico, descrito na Seção~\ref{sec:dynamic-graph-creation}. Além das variáveis de classe existentes que criamos para o grafo $G$ no algoritmo de conexidade em grafos dinâmicos, armazenaremos o peso da MSF decremental numa variável chamada \textit{pesoMSF}, que será simplesmente retornada quando consultarmos o peso da MSF decremental corrente chamando \texttt{extraiaPesoMSF}.

Também incluiremos um atributo do grafo chamado \textit{peso}, que é um mapa hash que armazena o peso das arestas. Para armazenar o peso $w$ de uma aresta $uv$, basta chamarmos $ \dotvar{G}{peso[u, v]} \leftarrow w$. O atributo \textit{peso} será fundamental para recalcular a variável \textit{pesoMSF} no decorrer das remoções do grafo.

Dessa forma, podemos apresentar o construtor da MSF decremental no Programa~\ref{prog:newDecrementalMSF}.

\begin{programruledcaption}{\texttt{MSFDecremental($n$, $E$)} \label{prog:newDecrementalMSF}}
    \noindent\textbf{Entrada}: Recebe o número $n$ de vértices do grafo e um conjunto de arestas $E$. \\
    \textbf{Saída}: Devolve um grafo $G$ com $n$ vértices e $m$ arestas ponderadas.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\left\lceil \lg n \right\rceil$
    $\dotvar{G}{nívelMax}$ := L
    $G.pesoMSF$ := 0
    \textbf{para} $i$ := $1$ \textbf{até} $L$ \textbf{faça}
        $G.F_i$ := \texttt{florestaDinâmica($n$)}
        $G.R_i$ := \texttt{listasDeAdjacênciasMinHeap($n$)}
    $\dotvar{G}{nível}$ := \texttt{novoMapaHash($n$)}
    $\dotvar{G}{peso}$ := \texttt{novoMapaHash($n$)}
    \texttt{ordene($E$)} (*@\hfill $\triangleright$ ordena as arestas do conjunto $E$ em ordem crescente@*)
    \textbf{para cada aresta} ($u$, $v$, $w$) \textbf{em} $E$ \textbf{faça}
        \texttt{adicioneMSF}($G$, $u$, $v$, $w$)
    \textbf{retorne} G
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Podemos notar algumas diferenças quando comparamos o construtor \texttt{MSFDecremental} com o \texttt{grafoDinâmico}. Na MSF decremental, além de inicializarmos $\left\lceil \lg n \right\rceil$ listas de adjacências e $\left\lceil \lg n \right\rceil$ florestas dinâmicas, ordenamos as arestas do conjunto $E$ em ordem crescente de peso e inserimos uma a uma chamando \texttt{adicioneMSF}, que está descrito abaixo.

\begin{programruledcaption}{\texttt{adicioneMSF($G$, $u$, $v$, $w$)} \label{prog:addMSF}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, com $u < v$, e o peso $w$ da aresta $uv$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ de peso $w$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := $L$
    $\dotvar{G}{peso[u, v]}$ := p
    \textbf{se} \texttt{conectadosFD($G.F_{L}$, $u$, $v$)} \textbf{então} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{adicioneLAMSF($G.R_{L}$, $u$, $v$, $w$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $v$)}
    \textbf{senão}
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ + p
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
        \texttt{atualizeÉNível($G.F_L$, $u$, $v$, $\textbf{verdadeiro}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Como citado antes, a rotina \texttt{adicioneMSF} é acionada apenas em \texttt{MSFDecremental}. Ademais, a única diferença entre a \texttt{adicioneMSF} e a \texttt{adicioneGD} que vimos é que, na primeira, estamos guardando o peso das arestas quando as inserimos no grafo. Portanto, \texttt{adicioneMSF} também consome tempo amortizado $\Oh(\lg n)$.


Para \texttt{adicioneMSF}, a invariante~\ref{invariant11} é preservada para o nível $i = \left\lceil \lg n \right\rceil$. Como estamos inserindo arestas de nível $\left\lceil \lg n \right\rceil$ em $F_{\left\lceil \lg n \right\rceil}$, então as florestas de níveis inferiores não são afetadas, mantendo-se, assim, as invariantes~\ref{invariant22} e \ref{invariant33} também.

\subsection{Consulta de peso da MSF decremental}
\label{sec:connectivity-test-MSF}

A rotina \texttt{extraiaPesoMSF}, que devolve o peso da MSF do grafo $G$, está descrita abaixo. 

\begin{programruledcaption}{\texttt{extraiaPesoMSF($G$)} \label{prog:extract-weight-MSF}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$. \\
    \textbf{Saída}: Devolve o peso da MSF de $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \textbf{retorne} $\dotvar{G}{pesoMSF}$
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

\raggedbottom

É fácil ver que \texttt{extraiaPesoMSF} consome tempo $\Oh(1)$. Além disso, como não estamos alterando as MSFs de $G$, então as três invariantes são preservadas.

\subsection{Remoção de arestas na MSF decremental}
\label{sec:decremental-MSF-edge-removal}

A remoção de arestas também é semelhante à do algoritmo de conexidade em grafos dinâmicos. A diferença é que a busca por alguma aresta substituta, feita na \texttt{substituaArestaMSF} agora, é dada por ordem crescente de peso das arestas reserva. 

Quando removemos uma aresta $uv$ de nível $i$ em $F_i$, quebramos uma componente desta floresta em $T_u$ e $T_v$, com $|T_u| \leq |T_v|$, e rebaixamos todas as arestas de $T_u$, da mesma forma como fazíamos antes em \texttt{substituaAresta}. Porém, agora procuramos por alguma reserva de peso mínimo dentre todas as reserva em $R_i$, e testamos se ela é uma substituta. Se não, a rebaixamos para $R_{i-1}$ e buscamos a próxima de peso mínimo em $R_i$. Assim, quando achamos uma substituta, conseguimos manter o peso da MST do grafo e ainda reconectar as duas componentes separadas devido à remoção de $uv$. 

Para facilitar o entendimento da substituição de aresta na MSF decremental, demonstraremos a remoção de uma aresta $uv$ da floresta em uma série de imagens. Na Figura~\ref{fig:example-replacement-msf1}, temos um grafo ponderado $G$ de $n = 10$ vértices. Para facilitar, assumiremos que, até o momento, só houve inserções de arestas. 

Temos também que $n = 10$ e $\left\lceil \lg 10 \right\rceil = 4$, logo o nível máximo $L$ da floresta é $4$ e,  consequentemente, $G = G_4$. Como todas as inserções só acontecem no nível $L$, no momento, em $F_4$, só temos arestas da floresta de nível $4$, enquanto $F_3$ contém apenas vértices isolados. Neste cenário, note que a remoção da aresta $uv$ da floresta, representada por uma linha tracejada na figura, acaba quebrando a única componente da floresta $F_4$ em duas, $T_u$ e $T_v$. Como $F_4$ é a floresta maximal de nível máximo de $G$, então removemos somente a $uv$ de $F_4$. 

\tikzset{weight/.style={font=\small, inner sep=1pt, fill=white}}

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[removed] (u) -- (v) node[midway, above, weight] {9};
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            %\draw[edge] (a) -- (u) node[midway, below] {};
            %\draw[edge] (a) -- (b) node[midway, below] {};
            %\draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Um grafo ponderado $G$ de 10 vértices, onde as arestas pretas são da floresta $F_4$, enquanto as vermelhas são reservas. A aresta $uv$ está prestes a ser removida. A floresta $F_{4}$ de $G$ de cima contém todas as arestas pretas recém-inseridas e as arestas vermelhas estão em $R_4$. A floresta de baixo é a $F_{3}$, com os vértices isolados, e $R_3$ também não tem nenhuma aresta.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf1}
\end{figure}

O próximo passo é rebaixar o nível de todas as arestas de nível~$4$ em $T_u$ para o nível~$3$. Dessa forma, as arestas de $T_u$ passam a estar em $F_3$, como se pode ver na Figura~\ref{fig:example-replacement-msf2}, pois agora elas passam a ser de nível $3$.  

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da remoção da aresta $uv$ em $G$. As arestas de nível $4$ de $T_u$ foram rebaixadas para o nível $3$, o que pode ser visto na floresta $F_{3}$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf2}
\end{figure}

Como $T_u$ e $T_v$ em $F_4$ ficaram separadas após a remoção de $uv$, precisamos encontrar, se existir, uma aresta reserva que possa reconectá-las. Note que agora precisamos percorrer as arestas reserva em ordem de peso. Entretanto, percorrer todas as arestas reservas de $R_4$ e selecionar a de menor peso é ineficiente, e por isso explicaremos como implementar essa busca por uma aresta substituta de menor peso na Seção~\ref{sec:forest-node-adjustments}.

Na Figura~\ref{fig:example-replacement-msf3}, percorremos as arestas reserva em ordem de peso em $R_4$ que tenham uma das pontas em~$T_u$. Para cada aresta percorrida, verificamos se a outra ponta dela incide em algum vértice de $T_v$. No nosso exemplo, olhamos para as arestas reserva em $R_4$, antes de encontrarmos a substituta, nesta ordem: $df$ (peso $10$), $dh$ (peso $11$), $bu$ (peso $12$), $uc$ (peso~$13$). Veja  que as rebaixamos para $R_3$ por não serem substitutas.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        
        \draw[reserveremoved] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserveremoved] (c) -- (u) node[pos=0.4, above, yshift=2pt, weight] {13}; % adjusted
        \draw[reserveremoved] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserveremoved] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da busca por uma aresta substituta em $R_4$. As arestas reserva de nível $4$ que estão tracejadas foram percorridas em ordem crescente de peso e estão prestes a ser removidas de $R_4$, pois foram rebaixadas para o nível $3$, como se pode ver em $R_3$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf3}
\end{figure}

Assim, a próxima aresta reserva de menor peso em $R_4$ que olharemos é a $ad$, de peso $14$. Como ela conecta $T_u$ a $T_v$, chamamos \texttt{adicioneFD($F_4$, $a$, $d$, $14$)} e $ad$ passa a ser uma aresta da floresta de peso $14$, ou seja, é removida de $R_4$. Como $i = 4$ é o nível máximo do grafo nesse exemplo, não precisamos chamar esta rotina para os níveis superiores e então terminamos a execução do algoritmo. A Figura~\ref{fig:example-replacement-msf4} ilustra essa etapa do algoritmo. 

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[edge] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted


        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação do grafo com a aresta substituta $ad$ por ser a de menor peso em $R_4$ que conecta $T_u$ a $T_v$ em $F_4$, tornando-se uma aresta da floresta.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf4}
\end{figure}



































A partir dessas imagens, fica fácil perceber que o método \texttt{removaMSF}, descrito abaixo, não há alterações em sua estrutura se comparado com \texttt{removaGD}, exceto na mudança de nomes de alguns métodos.

\begin{programruledcaption}{\texttt{removaMSF($G$, $u$, $v$)} \label{prog:removeGD-version-msf}}
    \noindent\textbf{Entrada}: Recebe dois vértices adjacentes $u$ e $v$ do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    i := $\dotvarm{G}{nível}{u,v}$
    $\dotvarm{G}{nível}{u,v}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        \textbf{para} j := i \textbf{até} L \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaArestaMSF($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLAMSF($G.R_i$, $u$, $v$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $u$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

O método \texttt{substituaArestaMSF}, que é uma versão ajustada de \texttt{substituaAresta}, será descrito mais em frente. Veremos que ele consome tempo amortizado $\Oh(\lg^2 n)$, e assim \texttt{removaMSF} também irá consumir tempo amortizado $\Oh(\lg^2 n)$.

\subsection{Ajustes em nós da floresta}
\label{sec:forest-node-adjustments}