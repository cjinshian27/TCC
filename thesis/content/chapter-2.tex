%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Algoritmo para MSF decremental}

\enlargethispage{.8\baselineskip}

Neste capítulo, estudaremos o problema da árvore geradora mínima em grafos dinâmicos. 
Dado um grafo conexo $G$ com um custo associado a cada uma de suas arestas, 
o problema da árvore geradora mínima consiste em determinar uma árvore geradora
de~$G$ com custo mínimo, onde o custo de uma árvore é a soma dos custos de suas arestas. 
Como estamos interessados em grafos dinâmicos, é natural remover a restrição de que o 
grafo seja conexo, e neste caso considerar florestas geradoras maximais de custo mínimo 
(MSF, do inglês, \emph{minimum spanning forest}). Chamamos um grafo com um custo 
associado a cada aresta de \textbf{grafo ponderado}. 

O problema da árvore geradora mínima em grafos ponderados (conexos) estáticos pode ser 
resolvido eficientemente, por exemplo, pelos algoritmos de Kruskal e de Prim. O algoritmo de Kruskal 
utiliza uma estrutura de dados clássica conhecida como union-find, enquanto que o algoritmo
de Prim utiliza uma fila de prioridades. Não há na literatura uma versão destes algoritmos 
para grafos dinâmicos. Isso talvez se deva à característica essencialmente sequencial destes
algoritmos, que modificam suas estruturas internas conduzidos por uma ordem de eventos.
Uma alteração no grafo poderia levar a uma alteração em toda a sequência de eventos 
nesses algoritmos a partir de um certo ponto, e com isso não há uma versão eficiente deles
que acomode alterações no grafo. 

Por outro lado, Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propuseram uma adaptação do seu algoritmo para conexidade em 
grafos dinâmicos, apresentado no Capítulo 2, para que este mantenha, de maneira eficiente, 
uma floresta geradora maximal de custo mínimo em um grafo ponderado que pode sofrer 
remoções de arestas.  Ou seja, eles propuseram um algoritmo que resolve de maneira 
eficiente o problema que chamamos de \textbf{MSF decremental}.  Neste capítulo, descreveremos
esse algoritmo, que é uma adaptação do algoritmo descrito no Capítulo 2 para que este 
passe a resolver o problema da MSF decremental.  

\section{Biblioteca da MSF decremental}
\label{sec:decremental-msf-library}

Implementar o algoritmo decremental para florestas geradoras maximais de custo mínimo resume-se à construção da seguinte biblioteca de forma eficiente:

\begin{itemize}
    \item \texttt{\textbf{MSFDecremental(n, E)}}: contrói e devolve um grafo ponderado $G$ com $n$ vértices e as arestas ponderadas dadas no conjunto $E$;
    \item \texttt{\textbf{consultePesoMSF(G)}}: devolve o peso de uma MSF do grafo ponderado $G$;
    \item \texttt{\textbf{removaMSF(G, u, v)}}: remove a aresta $uv$ do grafo ponderado $G$.
\end{itemize} 

Note que, diferente da biblioteca do algoritmo de conexidade em grafos dinâmicos, apresentada na Seção~\ref{sec:dynamic-graph-routines}, na MSF decremental não temos um método equivalente a \texttt{adicioneGD} disponível para o usuário. Em nossa implementação \cite{chung2025}, para criarmos um grafo $G$ de $n$ vértices e $m$ arestas ponderadas dadas em $E$, acionamos~ \texttt{MSFDecremental($n$,~$E$)}, onde criamos, como no problema da conexidade em grafos dinâmicos, $\left\lceil \lg n \right\rceil$ florestas dinâmicas e $\left\lceil \lg n \right\rceil$ listas de adjacências, com $n$ vértices isolados. Em seguida, ordenamos e inserimos as $m$ arestas de $E$ em ordem crescente de peso, usando uma biblioteca pronta do $\emph{C++}$ para ordená-las, que consome tempo esperado $\Oh(m \lg n)$. Estas $m$ arestas são  inseridas uma a uma acionando uma rotina que chamamos de  \texttt{adicioneMSF(u, v, w)}, onde $u$ e $v$ são pontas da aresta e $w$ é o peso dela.

A rotina \texttt{adicioneMSF} é acionada somente dentro do construtor e tem custo amortizado $\Oh(\lg n)$. Ela é uma versão da \texttt{adicioneGD} que acomoda os pesos das arestas como veremos adiante. Por ser uma rotina privada, ou seja, não está disponível para o usuário, após a inserção destas arestas, não é permitido mais operações de inserção, somente de remoção de arestas. Para o usuário, então, só estarão disponíveis as rotinas \texttt{consultePesoMSF} e \texttt{removaMSF}. A versão totalmente dinâmica, que inclui a rotina \texttt{adicioneMSF} para o usuário, será estudada posteriormente no Capítulo~\ref{chapter:fully-MSF}.

O construtor \texttt{MSFDecremental}, devido à ordenação de arestas e à chamada ao método \texttt{adicioneMSF}, possui consumo de tempo $\Oh(m \lg n)$. Já a rotina \texttt{custoMSF} possui consumo de tempo $\Oh(1)$. Como estes dois métodos são mais simples, passaremos brevemente sobre eles, e detalharemos mais a rotina \texttt{removaMSF}, que possui a rotina auxiliar \texttt{substituaArestaMSF} implementada de maneira diferente do \texttt{substituaAresta} do algoritmo de conexidade em grafos dinâmicos. 

Usaremos várias definições já apresentadas no algoritmo de conexidade em grafos dinâmicos, incluindo as mesmas invariantes apresentadas na Seção~\ref{sec:level-slicing}, os mesmos tipos de arestas da Seção~\ref{sec:dynamic-graph-edge-types} e nós das florestas apresentados na Seção~\ref{sec:graph-nodes}. A seguir, apresentaremos as rotinas da MSF decremental e alguns ajustes a serem feitos. 

\subsection{Listas de adjacências}
\label{sec:adjancency-lists-min-heap}

Na Seção~\ref{sec:dynamic-graph-edge-types}, apresentamos a biblioteca de \texttt{listasDeAdjacências}, onde usamos um mapa hash para inserir ou remover um vértice $v$ da lista de $u$, além de percorrer os vizinhos da lista de $u$. No algoritmo da MSF decremental, quando removemos uma aresta de nível $i$ da floresta $F_i$, uma componente desta será quebrada em duas, $T_u$ e $T_v$, da mesma forma que no algoritmo de conexidade em grafos dinâmicos. A diferença é que, no caso da MSF decremental, precisamos buscar por uma aresta substituta que tenha o menor peso e que ligue $T_u$ a~$T_v$. Não podemos simplesmente percorrer todos os vizinhos $y$ de cada vértice $x$ em $T_u$, verificar se $xy$ reconecta as componentes separadas e se é de menor peso dentre todas as substitutas, já que isso seria ineficiente.

Assim, fica claro que seria bom percorrer as arestas reserva em ordem crescente de peso e testar se alguma é substituta nesta ordem. Por isso, em vez de usar um mapa hash para armazenar os vizinhos de cada vértice, usaremos um min-heap. Na verdade, como estamos trabalhando com nós de vértice e de aresta, cada nó de vértice $u$ guardará um min-heap com os vizinhos de $u$ em $R_i$, onde a chave dessa estrutura de dados para um vizinho $v$ será o peso da aresta $uv$. Nós de aresta também guardarão um min-heap, porém vazio. 

Os métodos principais (remoção, inserção e extração do vértice de chave mínima) que usamos no min-heap consomem tempo O($\lg n)$ usando uma implementação tradicional de heap, como a descrita no Capítulo 6 de Thomas H. Cormen et al. \cite{clrs}. O resto dos métodos (consulta do vértice de chave mínima, da quantidade de elementos na min-heap e se a min-heap está vazia) consomem tempo constante, e eles serão necessários para buscar a aresta substituta de peso, como descreveremos mais à frente.

Como o min-heap é uma estrutura de dados bastante conhecida, não iremos descrever a sua implementação em detalhes. O objetivo é ressaltar as diferenças entre as listas de adjacências utilizadas no algoritmo de conexidade em grafos dinâmicos e na MSF decremental, e como essa mudança afetará o comportamento do método \texttt{substituaArestaMSF} da MSF decremental.

Assim, com base na implementação clássica do min-heap, podemos definir a biblioteca das listas de adjacências da MSF decremental. 

\begin{itemize}
    \item \texttt{\textbf{listasDeAdjacênciasMSF(n)}}: constrói e devolve um grafo com $n$ vértices e sem arestas, representado por listas de adjacências armazenadas em min-heaps;

    \item \texttt{\textbf{adicioneLAMSF(R, u, v, w)}}: adiciona o vértice $u$ na lista de adjacências de $v$ em $R$ e vice-versa, considerando que o peso de $uv$ é $w$;
    
    \item \texttt{\textbf{removaLAMSF(R, u, v)}}: remove o vértice $u$ da lista de adjacências de $v$ em $R$ e vice-versa;
    
    \item \texttt{\textbf{consulteMinLAMSF(R, u)}}: retorna um par ($v$, $w$), onde $v$ é um vértice do min-heap de $u$ em $R$ com chave mínima;

\end{itemize} 

Uma chamada à rotina \texttt{adicioneLAMSF(R, u, v, w)} adiciona o par ($u$, $w$) no min-heap de $v$ e também adiciona o par ($v$, $w$) no min-heap de $u$, consumindo tempo $\Oh(\lg n)$. Similarmente, uma chamada à rotina \texttt{removaLAMSF(R, u, v)} remove o par ($u$,~$w$) do min-heap de $v$ e também remove o par ($v$, $w$) do min-heap de $u$, consumindo também tempo $\Oh(\lg n)$. Já o método \texttt{consulteMinLAMSF} consome tempo $\Oh(1)$, já que estamos apenas consultando a chave mínima do min-heap de um vértice.

\section{Ajustes nas invariantes}

Como agora estamos tratando de florestas geradoras maximais de custo mínimo (MSFs), ajustaremos somente a primeira invariante, onde substituímos o termo floresta maximal por MSF, como se pode ver abaixo.

\begin{enumerate}[label=(\Roman*)]
    \item \label{invariant11} $F_i$ é uma MSF de $G_i$ para todo $1 \leq i \leq  \left\lceil \lg n \right\rceil$;
    
    \item \label{invariant22} $F_i \subseteq F_{i+1}$ para todo $1 \leq i \leq \left\lceil \lg n \right\rceil - 1$;
    
    \item \label{invariant33} Cada componente da floresta $F_i$ possui no máximo $2^i$ vértices.
\end{enumerate}

A partir deste momento, usaremos estas três invariantes e mostraremos como elas são preservadas no decorrer das modificações no grafo.

\section{Rotinas da biblioteca da MSF decremental}

\subsection{Criação do grafo}

O construtor \texttt{MSFDecremental} é bem parecido com o do grafo dinâmico, descrito na Seção~\ref{sec:dynamic-graph-creation}. Além das variáveis de classe existentes que criamos para o grafo $G$ no algoritmo de conexidade em grafos dinâmicos, armazenaremos o peso da MSF numa variável chamada \textit{pesoMSF}, que será simplesmente retornada quando consultarmos o peso da MSF decremental corrente, chamando \texttt{consultePesoMSF}.

Também incluiremos um atributo do grafo chamado \textit{peso}, que é um mapa hash que armazena o peso das arestas. Para armazenar o peso $w$ de uma aresta $uv$, basta chamarmos $ \dotvar{G}{peso[u, v]} \leftarrow w$. O atributo \textit{peso} será fundamental para recalcular a variável \textit{pesoMSF} no decorrer das remoções de arestas do grafo.

Dessa forma, podemos apresentar o construtor da MSF decremental no Programa~\ref{prog:newDecrementalMSF}, que usa a rotina \texttt{adicioneMSF} apresentada no Programa~\ref{prog:addMSF}.

\begin{programruledcaption}{\texttt{MSFDecremental($n$, $E$)} \label{prog:newDecrementalMSF}}
    \noindent\textbf{Entrada}: Recebe o número $n$ de vértices do grafo e um conjunto de arestas $E$. \\
    \textbf{Saída}: Devolve um grafo $G$ com $n$ vértices e $m$ arestas ponderadas.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\left\lceil \lg n \right\rceil$
    $\dotvar{G}{nívelMax}$ := L
    $\dotvar{G}{pesoMSF}$ := 0
    \textbf{para} $i$ := $1$ \textbf{até} $L$ \textbf{faça}
        $G.F_i$ := \texttt{florestaDinâmica($n$)}
        $G.R_i$ := \texttt{listasDeAdjacênciasMSF($n$)}
    $\dotvar{G}{nível}$ := \texttt{novoMapaHash($n$)}
    $\dotvar{G}{peso}$ := \texttt{novoMapaHash($n$)}
    \texttt{ordene($E$)} (*@\hfill $\triangleright$ ordena as arestas do conjunto $E$ em ordem crescente de peso@*)
    \textbf{para cada aresta} ($u$, $v$, $w$) \textbf{em} $E$ \textbf{faça}
        \texttt{adicioneMSF}($G$, $u$, $v$, $w$)
    \textbf{retorne} G
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Podemos notar algumas diferenças quando comparamos o construtor \texttt{MSFDecremental} com o construtor \texttt{grafoDinâmico}. Na MSF decremental, além de inicializarmos $\left\lceil \lg n \right\rceil$ listas de adjacências e $\left\lceil \lg n \right\rceil$ florestas dinâmicas, ordenamos as arestas do conjunto $E$ em ordem crescente de peso e inserimos uma a uma chamando \texttt{adicioneMSF}, que está descrita abaixo. Note que esta é a primeira versão do método \texttt{adicioneMSF}. A versão completa dele será descrita na Seção~\ref{sec:addMSF-finalVersion}.

\begin{programruledcaption}{\texttt{adicioneMSF($G$, $u$, $v$, $w$)} \label{prog:addMSF}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, com $u < v$, e o peso $w$ da aresta $uv$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ de peso $w$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := $L$
    $\dotvar{G}{peso[u, v]}$ := p
    \textbf{se} \texttt{conectadosFD($G.F_{L}$, $u$, $v$)} \textbf{então} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{adicioneLAMSF($G.R_{L}$, $u$, $v$, $w$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $v$)}
    \textbf{senão}
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ + w
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
        \texttt{atualizeÉNível($G.F_L$, $u$, $v$, $\textbf{verdadeiro}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Como citado antes, a rotina \texttt{adicioneMSF} é acionada apenas em \texttt{MSFDecremental}. Ademais, a única diferença entre a \texttt{adicioneMSF} e a \texttt{adicioneGD} que vimos na Seção~\ref{sec:code-edge-addition-second-version} é que, na primeira, estamos guardando o peso das arestas quando as inserimos no grafo. Portanto, \texttt{adicioneMSF} também consome tempo amortizado $\Oh(\lg n)$.


Para \texttt{adicioneMSF}, a invariante~\ref{invariant11} é preservada para o nível $i = \left\lceil \lg n \right\rceil$, já que estamos inserindo as arestas do grafo em ordem crescente de peso. Essa construção basicamente simula o algoritmo de Kruskal. Como estamos inserindo arestas de nível $\left\lceil \lg n \right\rceil$ em $F_{\left\lceil \lg n \right\rceil}$, então as florestas de níveis inferiores não são afetadas, mantendo-se, assim, as invariantes~\ref{invariant22} e \ref{invariant33} também.

\subsection{Consulta de peso da MSF}
\label{sec:connectivity-test-MSF}

A rotina \texttt{consultePesoMSF}, que devolve o peso de uma MSF do grafo $G$, está descrita abaixo.     

\begin{programruledcaption}{\texttt{consultePesoMSF($G$)} \label{prog:extract-weight-MSF}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$. \\
    \textbf{Saída}: Devolve o peso de uma MSF de $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \textbf{retorne} $\dotvar{G}{pesoMSF}$
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

\raggedbottom

É fácil ver que \texttt{consultePesoMSF} consome tempo $\Oh(1)$. Além disso, como não estamos alterando nem o grafo nem as florestas do grafo $G$, então as três invariantes são preservadas.

\subsection{Remoção de arestas}
\label{sec:decremental-MSF-edge-removal}

A remoção de arestas também é semelhante à do algoritmo de conexidade em grafos dinâmicos. A diferença é que a busca por alguma aresta substituta, feita na \texttt{substituaArestaMSF} agora, é dada por ordem crescente de peso das arestas reserva. 

Quando removemos de $F_i$ uma aresta $uv$ de nível $i$, quebramos uma componente desta floresta em $T_u$ e $T_v$, com $|T_u| \leq |T_v|$, e rebaixamos todas as arestas de $T_u$, da mesma forma como fazíamos antes em \texttt{substituaAresta}. Porém, agora buscamos alguma aresta reserva de peso mínimo dentre todas as arestas reserva em $R_i$ incidente a $T_u$, e testamos se ela é uma substituta. Se não é, a rebaixamos para $R_{i-1}$ e buscamos a próxima de peso mínimo em $R_i$ incidente a $T_u$. Assim, quando achamos uma substituta, conseguimos manter o peso da MSF do grafo, reconectando as duas componentes separadas devido à remoção de $uv$. 

Para facilitar o entendimento da substituição de aresta na MSF decremental, demonstraremos a remoção de uma aresta $uv$ da floresta em uma série de imagens. Na Figura~\ref{fig:example-replacement-msf1}, temos um grafo ponderado $G$ e assumiremos que essa é a primeira remoção depois da criação do grafo.

No nosso exemplo, $G$ tem $n = 10$ vértices. Sabemos que $\left\lceil \lg 10 \right\rceil = 4$, logo o nível máximo $L$ da floresta é $4$ e,  consequentemente, $G = G_4$. Como, na construção, todas as inserções ocorrem no nível $L$ em $F_4$, só temos arestas da floresta de nível $4$, enquanto $F_3$ contém apenas vértices isolados. Neste cenário, note que a remoção da aresta $uv$ da floresta, representada por uma linha tracejada na figura, acaba quebrando a única componente da floresta $F_4$ em duas, $T_u$ e $T_v$. Como $F_4$ é a floresta maximal de nível máximo de $G$, então removemos a $uv$ somente de $F_4$. 

\tikzset{weight/.style={font=\small, inner sep=1pt, fill=white}}

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[removed] (u) -- (v) node[midway, above, weight] {9};
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            %\draw[edge] (a) -- (u) node[midway, below] {};
            %\draw[edge] (a) -- (b) node[midway, below] {};
            %\draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Um grafo ponderado $G$ de 10 vértices, onde as arestas pretas são da floresta $F_4$, enquanto as vermelhas são reservas. A aresta $uv$ está prestes a ser removida. A floresta $F_{4}$ de $G$ de cima contém todas as arestas pretas recém-inseridas e as arestas vermelhas estão em $R_4$. A floresta de baixo é a $F_{3}$, com os vértices isolados, e $R_3$ também não tem nenhuma aresta.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf1}
\end{figure}

O próximo passo é rebaixar todas as arestas de nível~$4$ em $T_u$ para o nível~$3$. Dessa forma, as arestas de $T_u$ passam a estar em $F_3$, como se pode ver na Figura~\ref{fig:example-replacement-msf2}, pois agora elas passam a ser de nível $3$. Como $T_u$ e $T_v$ em $F_4$ ficaram separadas após a remoção de $uv$, precisamos encontrar, se existir, uma aresta reserva que possa reconectá-las. Note que agora precisamos percorrer as arestas reserva em ordem de peso. Entretanto, percorrer todas as arestas reserva de $R_4$ incidentes a $T_u$ e selecionar a de menor peso é ineficiente. Isso porque, se a aresta de peso mínimo não é uma substituta, teremos que buscar a próxima de menor peso e fazer esse processo novamente, o que acaba comprometendo com a performance do algoritmo. Por isso, explicaremos como implementar essa busca eficiente por uma aresta substituta de menor peso na Seção~\ref{sec:forest-node-adjustments}.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da remoção da aresta $uv$ em $G$. As arestas de nível $4$ de $T_u$ foram rebaixadas para o nível $3$, o que pode ser visto na floresta $F_{3}$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf2}
\end{figure}

Na Figura~\ref{fig:example-replacement-msf3}, percorremos as arestas reserva em ordem de peso em $R_4$ que tenham uma das pontas em~$T_u$. Para cada aresta percorrida, verificamos se a outra ponta dela incide em algum vértice de $T_v$. No nosso exemplo, olhamos para as arestas reserva em $R_4$, antes de encontrarmos a substituta, nesta ordem: $bu$ (peso $12$) e $uc$ (peso~$13$). Veja  que as rebaixamos para $R_3$ por não serem substitutas.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};
        
        \draw[reserveremoved] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserveremoved] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted


        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da busca por uma aresta substituta em $R_4$. As arestas reserva de nível $4$ que estão tracejadas foram percorridas em ordem crescente de peso e estão prestes a serem removidas de $R_4$, pois foram rebaixadas para o nível $3$, como se pode ver em $R_3$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf3}
\end{figure}

Assim, a próxima aresta reserva de menor peso em $R_4$ que olharemos é a $ad$, de peso $14$. Como ela conecta $T_u$ a $T_v$, chamamos \texttt{adicioneFD($F_4$, $a$, $d$)} e $ad$ passa a ser uma aresta da floresta, ou seja, é removida de $R_4$. Como $i = 4$ é o nível máximo do grafo nesse exemplo, não precisamos chamar esta rotina para os níveis superiores e então terminamos a execução do algoritmo. A Figura~\ref{fig:example-replacement-msf4} ilustra essa etapa do algoritmo. 

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[edge] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (a) -- (c) node[midway, above, yshift=0pt, weight] {16};
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted


        \end{tikzpicture}
    \end{minipage}
    \caption{Representação do grafo com a aresta substituta $ad$ por ser a de menor peso em $R_4$ que conecta $T_u$ a $T_v$, tornando-se uma aresta da floresta $F_4$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf4}
\end{figure}



































A partir dessas imagens, percebe-se que o método \texttt{removaMSF}, descrito abaixo, é bem semelhante ao método \texttt{removaGD}, exceto que no primeiro precisamos recalcular o peso da MSF de $G$ quando removemos uma aresta da floresta. Note que o \texttt{removaMSF} descrito abaixo é a primeira versão deste método. Descreveremos a sua versão completa na Seção~\ref{sec:removeMSF-finalVersion}

\begin{programruledcaption}{\texttt{removaMSF($G$, $u$, $v$)} \label{prog:removeGD-version-msf}}
    \noindent\textbf{Entrada}: Recebe dois vértices adjacentes $u$ e $v$ do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    i := $\dotvarm{G}{nível}{u,v}$
    $\dotvarm{G}{nível}{u,v}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        w := $\dotvar{G}{peso[u, v]}$
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ - $w$
        \textbf{para} j := i \textbf{até} L \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaArestaMSF($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLAMSF($G.R_i$, $u$, $v$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $u$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

O método \texttt{substituaArestaMSF}, que é uma versão ajustada de \texttt{substituaAresta}, será descrito mais adiante. Por enquanto, sabemos que \texttt{removaMSF} consome tempo $\Oh(\lg^2 n)$ mais o custo de \texttt{substituaArestaMSF}.

\subsection{Ajustes em nós das florestas}
\label{sec:forest-node-adjustments}

No algoritmo de conexidade em grafos dinâmicos, vimos que os nós da floresta guardam dois campos, \textit{incideArestaReservaDeNível} e \textit{éNível}, além de dois contadores, \textit{arestasDeNível} e \textit{arestasReservasDeNível}. Mostramos também alguns métodos que atualizam e utilizam estes campos para realizar a busca eficiente de uma aresta substituta.

Para o algoritmo da MSF decremental, além destes campos apresentados, precisaremos de dois campos extras para cada nó da floresta: \textit{peso} e \textit{pesoMínimo}. O primeiro campo armazena o peso de um nó de aresta (nós de vértice guardam $\infty$ neste campo). Na floresta $F_i$, cada nó de vértice sabe facilmente o peso mínimo de uma aresta reserva de $R_i$ incidente nele. Assim, o campo \textit{pesoMínimo} de cada nó $p$ de floresta guarda o peso mínimo de uma aresta reserva de $R_i$ incidente a algum vértice cujo nó está na subárvore de $p$.

Como o peso de cada aresta ponderada nunca muda, então não precisamos atualizar o seu peso. Entretanto, à medida que vamos removendo arestas da floresta $F_i$, quebramos alguma componente dela em duas e precisamos buscar alguma aresta substituta para reconectar as duas componentes separadas. Assim, quando procuramos por alguma aresta substituta em $R_i$, podemos neste processo rebaixar algumas arestas de $R_i$ para $R_{i-1}$ e o \textit{pesoMínimo} dos nós em $F_i$ e em $F_{i-1}$ precisa ser atualizado. Se em $R_i$ acharmos uma substituta, ela se tornará uma aresta da floresta $F_i$ e precisamos também atualizar o \textit{pesoMínimo} de alguns nós em $F_i$, que agora será o peso mínimo dentre as arestas reserva restantes em $R_i$.

Por isso, fica claro que precisamos de um método que atualize o campo \textit{pesoMínimo} dos nós. Para isso, criamos o método \texttt{atualizePesoMínimo}, que está descrito abaixo. Na nossa implementação, ele é usado em métodos quando estamos fazendo alguma alteração em $R_i$, e também é usado ao acionarmos as operações \texttt{splay}, sempre que essa executa uma rotação. 

\begin{programruledcaption}{\texttt{atualizePesoMínimo($F$, $R$, $u$)} \label{prog:updateMinWeight}}
    \noindent\textbf{Entrada}: Recebe um vértice $u$, as listas de adjacências $R$ e a floresta $F$.\\
    \noindent\textbf{Efeito}: Atualiza o atributo \textit{pesoMínimo} do nó de vértice $u$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    nóUU := F.nó[$u$, $u$]
    \texttt{splay($\emph{nóUU}$)}
    c := $\infty$ 
    \textbf{se} nóUU.esq $\neq$ \texttt{NIL} \textbf{e} \textit{nóUU.esq.pesoMínimo} < c \textbf{então}
        c := \textit{nóUU.esq.pesoMínimo}
    \textbf{se} nóUU.dir $\neq$ \texttt{NIL} \textbf{e} \textit{nóUU.dir.pesoMínimo} < c \textbf{então}
        c := \textit{nóUU.dir.pesoMínimo}
    \textbf{se} R[$u$] $\neq \emptyset$  \textbf{então}
        ($v$, $w$) := \texttt{consulteMinLAMSF($R$, $u$)}
        \textbf{se} w < c \textbf{então}
            c := w
    nóUU.pesoMínimo := c
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

Como se pode ver, o Programa~\ref{prog:updateMinWeight} consome tempo amortizado $\Oh(\lg n)$ por conta da operação \texttt{splay}. Além disso, ele não altera a floresta $F$, altera somente uma das árvores binárias que a representam. Portanto, todas as três invariantes são preservadas.

Para entendermos como estes dois campos extras aparecem em cada nó da floresta, usaremos um exemplo de um grafo ponderado $G$ de $5$ vértices e $7$ arestas ponderadas, como se pode ver na Figura~\ref{fig:generic-graph-example-1}. A Figura~\ref{fig:euler-tour-balanced-field-propagation-1} mostra estes campos nos nós da floresta $F_L$ de $G$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node] (a) at (0,1.5) {$a$};
        \node[node] (b) at (4,1.5) {$b$};
        \node[node] (c) at (4,-0.7) {$c$};
        \node[node] (d) at (1.5,-0.7) {$d$};
        \node[node] (e) at (-1.5,-0.7) {$e$};

        \draw[edge] (a) -- (b) node[midway, above, weight] {1};;
        \draw[edge] (c) -- (d) node[midway, above, weight] {2};;
        \draw[edge] (d) -- (a) node[midway, above, weight] {3};;
        \draw[edge] (a) -- (e) node[midway, above, weight] {4};;

        \draw[reserve] (e) -- (d) node[midway, above, weight] {5};
        \draw[reserve] (b) -- (c) node[midway, above, weight] {6};
        \draw[reserve] (a) -- (c) node[midway, above, weight] {7};


    \end{tikzpicture}
    \caption{Grafo ponderado $G$ de $5$ vértices e $7$ arestas ponderadas. Arestas pretas são da floresta e formam a MSF de $G$, enquanto as vermelhas são arestas reserva.}
    \label{fig:generic-graph-example-1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node, label=below:{(3, 5)}] (ad) at (0, 0) {$ad$};
        \node[node, label=below:{(1, 5)}] (ab) at (-4.5, -1.5) {$ab$};
        \node[node, label=below:{(2, 5)}] (cd) at (4.5, -1.5) {$cd$};
        \node[node, label=below:{(2, 5)}] (dc) at (3, -3) {$dc$};
        \node[node, label=below:{($\infty$, $5$)}] (dd) at (1.5, -4.5) {$dd$};
        \node[node, label=below:{($\infty$, $6$)}] (cc) at (4.5, -4.5) {$cc$};
        
        
        \node[node, label=below:{(3, $\infty$)}] (da) at (6, -3) {$da$};
        \node[node, label=below:{(4, $\infty$)}] (ae) at (7.5, -4.5) {$ae$};
        
        
        \node[node, label=below:{(4, 5)}] (ea) at (-6, -3) {$ea$};
        \node[node, label=below:{($\infty$, 5)}] (ee) at (-7.5, -4.5) {$ee$};
        \node[node, label=below:{($\infty$, 7)}] (aa) at (-4.5, -4.5) {$aa$};


        \node[node, label=below:{($\infty$, 6)}] (bb) at (-3, -3) {$bb$};
        \node[node, label=below:{(1, $\infty$)}] (ba) at (-1.5, -4.5) {$ba$};

        

        % tree edges (normal black edges)
        \draw[edge] (ad) -- (ab) node[midway, below] {};
        \draw[edge] (ad) -- (cd) node[midway, below] {};
        \draw[edge] (cd) -- (dc) node[midway, below] {};
        \draw[edge] (cd) -- (da) node[midway, below] {};
        \draw[edge] (bb) -- (ba) node[midway, below] {};
        \draw[edge] (ea) -- (ee) node[midway, below] {};
        \draw[edge] (ea) -- (aa) node[midway, below] {};
        \draw[edge] (dc) -- (dd) node[midway, below] {};
        \draw[edge] (dc) -- (cc) node[midway, below] {};
        \draw[edge] (da) -- (ae) node[midway, below] {};

        \draw[edge] (ab) -- (ea) node[midway, below] {};
        \draw[edge] (ab) -- (bb) node[midway, below] {};


    \end{tikzpicture}
    \caption{Árvore da única componente da floresta $F_L$ do grafo $G$ da Figura~\ref{fig:generic-graph-example-1}, onde embaixo de cada nó há um par de números. O primeiro número indica o atributo \textit{peso} do nó, enquanto o segundo número indica o atributo \textit{pesoMínimo}, calculado através dos nós em sua subárvore.}
    \label{fig:euler-tour-balanced-field-propagation-1}
\end{figure}

A seguir, o Programa~\ref{prog:findMinWeightEdge} apresenta o método \texttt{procureNóIncideArestaDePesoMínimo}, que procura e retorna o nó de vértice que incide em uma aresta reserva de peso mínimo. Ele será usado no método \texttt{substituaArestaMSF}, que descreveremos na Seção~\ref{sec:replaceMSF}.

\begin{programruledcaption}{\texttt{procureNóIncideArestaDePesoMínimo($R$, $p$)} \label{prog:findMinWeightEdge}}
    \noindent\textbf{Entrada}: Recebe um nó $p$ de uma floresta com o atributo \textit{arestasReservasDeNível} $> 0$ e as listas de adjacências $R$.
    \\
    \noindent\textbf{Saída}: Devolve um nó de vértice incidente a uma aresta reserva de peso mínimo.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    c := $\infty$
    (x, y) := p.vértices
    \textbf{se} $x$ = $y$ \textbf{e} R[x] $\neq \emptyset$ \textbf{então} (*@\hfill $\triangleright$ verificamos se $p$ é um nó de vértice@*)
        ($v$, $w$) := \texttt{consulteMinLAMSF}($R$, $p$)
        c := w
    \textbf{se} c $\neq \infty$ \textbf{e} p.pesoMínimo = c \textbf{então}
        retorne p
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{e} p.esq.pesoMínimo = p.pesoMínimo \textbf{então}
        retorne \texttt{procureNóIncideArestaDePesoMínimo($R$, $\emph{p.esq}$)}
    \textbf{senão}
        retorne \texttt{procureNóIncideArestaDePesoMínimo($R$, $\emph{p.dir}$)}
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

% Na linha $3$ do Programa~\ref{prog:findMinWeightEdge}, estamos interessados em saber o tipo de nó da floresta comparando os valores das pontas deste nó. Se forem iguais, temos um nó de vértice e podemos verificar se a chave mínima do min-heap dele é igual ao valor do seu campo \textit{pesoMínimo}, como temos na linha $6$. Se for, simplesmente retornamos o nó $p$. Se não for, percorremos a subárvore esquerda ou a subárvore direita do nó dependendo de onde o valor do campo \textit{pesoMínimo} da raiz está vindo. 

Veja que o Programa~\ref{prog:findMinWeightEdge} não altera o grafo, e, portanto, as invariantes são preservadas. Como a Euler tour tree é balanceada, então o consumo de tempo de cada percurso é $\Oh(\lg n)$ (amortizado em nossa implementação, onde sempre realizamos um \texttt{splay} no nó devolvido). 

\subsection{Versão completa da rotina de adição de arestas}
\label{sec:addMSF-finalVersion}

A versão completa do método \texttt{adicioneMSF} está descrita abaixo. Ao inserirmos uma aresta reserva $uv$ em $R_L$, precisamos atualizar o atributo \textit{pesoMínimo} dos nós de vértice $u$ e $v$ de $F_L$, como se pode ver nas linhas $6$ e $7$. Isso porque se o peso de $uv$ é o menor dentre todas as arestas reserva inseridas em $R_L$ até o momento, o campo \textit{pesoMínimo} de $u$ e de $v$ então passa a ser o peso de $uv$. Assim, a complexidade de tempo da versão final de \texttt{adicioneMSF} continua sendo $\Oh(\lg n)$.

\begin{programruledcaption}{\texttt{adicioneMSF($G$, $u$, $v$, $w$)} \label{prog:addMSF-final-version}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, com $u < v$, e o peso $w$ da aresta $uv$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ de peso $w$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := $L$
    $\dotvar{G}{peso[u, v]}$ := $w$
    \textbf{se} \texttt{conectadosFD($G.F_{L}$, $u$, $v$)} \textbf{então} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{adicioneLAMSF($G.R_{L}$, $u$, $v$, $w$)}
        \texttt{atualizePesoMínimo($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{atualizePesoMínimo($G.F_{L}$, $G.R_{L}$, $v$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $v$)}
    \textbf{senão}
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ + w
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
        \texttt{atualizeÉNível($G.F_L$, $u$, $v$, $\textbf{verdadeiro}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}


\subsection{Versão completa da rotina de remoção de arestas}
\label{sec:removeMSF-finalVersion}

A versão completa do método \texttt{removaMSF} está descrita abaixo. 

\begin{programruledcaption}{\texttt{removaMSF($G$, $u$, $v$)} \label{prog:removeGD-version-msf-final-version}}
    \noindent\textbf{Entrada}: Recebe dois vértices adjacentes $u$ e $v$ do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    i := $\dotvarm{G}{nível}{u,v}$
    $\dotvarm{G}{nível}{u,v}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        w := $\dotvar{G}{peso[u, v]}$
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ - $w$
        \textbf{para} j := i \textbf{até} L \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaArestaMSF($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLAMSF($G.R_i$, $u$, $v$)}
        \texttt{atualizePesoMínimo($G.F_{i}$, $G.R_{i}$, $u$)}
        \texttt{atualizePesoMínimo($G.F_{i}$, $G.R_{i}$, $v$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $u$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Ao removermos uma aresta reserva $uv$ de $R_i$, precisamos atualizar o atributo \textit{pesoMínimo} dos nós de vértice $u$ e $v$ de $F_i$, como se pode ver nas linhas $12$ e $13$. Isso porque se o peso de $uv$ era o menor dentre todas as arestas reserva restantes, então o atributo \texttt{pesoMínimo} de $u$ e de $v$ passa a ser o peso da aresta reserva de segundo menor peso em $R_i$. Assim, a complexidade de tempo da versão final de \texttt{removaMSF} continua sendo $\Oh(\lg^2 n)$ mais o custo da rotina \texttt{substituaArestaMSF}, que será descrita na seção seguinte.

\subsection{Rotina de substituição de aresta}
\label{sec:replaceMSF}

Para descrever a rotina \texttt{substituaArestaMSF} do Programa~\ref{prog:replaceMSF}, usaremos vários dos métodos auxiliares já apresentados, além de alguns métodos e campos novos adicionados aos nós das florestas, como vimos na Seção~\ref{sec:forest-node-adjustments}. Mostraremos também a rotina \texttt{testeSubstitutaMSF}, que é uma versão ajustada da rotina \texttt{testeSubstituta} que vimos antes. 

\begin{programruledcaption}{\texttt{substituaArestaMSF($G$, $i$, $u$, $v$)} \label{prog:replaceMSF}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, e o nível $i$ da aresta $uv$. \\
    \noindent\textbf{Efeito}: Adiciona uma aresta substituta de peso mínimo em $G$, se ela existir.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    \textbf{para} j := i \textbf{até} $L$ \textbf{faça}
        $T_u$ := \texttt{splay($G.F_j.\emph{nó}[u, u]$)}  (*@\hfill $\triangleright$ torna o nó $uu$ raiz de $T_u$@*)
        $T_v$ := \texttt{splay($G.F_j.\emph{nó}[v, v]$)}  (*@\hfill $\triangleright$ torna o nó $vv$ raiz de $T_v$@*)    
        \textbf{se} $T_u$.tam > $T_v$.tam \textbf{então}
            $T_u \leftrightarrow T_v$
        \textbf{enquanto} $T_u$.arestasDeNível > 0 \textbf{faça} 
            nóXY := \texttt{procureArestaDeNível($T_u$)}
            \texttt{splay($\emph{nóXY}$)}
            $T_u$ := nóXY
            \texttt{rebaixeNívelDaAresta($G$, $\emph{nóXY}$, j)}
        \textbf{enquanto} $T_u$.arestasReservasDeNível > 0     \textbf{faça}
            nóXX := \texttt{procureNóIncideArestaDePesoMínimo($R_j$, $T_u$)}
            \texttt{splay($\emph{nóXX}$)}
            $T_u$ := nóXX
            ($x$, $x$) := nóXX.vértices
            ($y$, $w$) := \texttt{consulteMinLAMSF($R_j$, $x$)} 
            se \texttt{testeSubstitutaMSF($G$, $x$, $y$, $w$, $j$)} \textbf{então} 
                \textbf{retorne}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Veja que já vimos as linhas $1$ a $11$ do Programa~\ref{prog:replaceMSF}, pois elas são exatamente iguais a esse mesmo trecho do código do Programa~\ref{prog:replaceGD}. Isso quer dizer que o rebaixamento de arestas da floresta acontece da mesma forma que no algoritmo de conexidade em grafos dinâmicos. O que muda é somente a forma como procuramos por alguma aresta substituta.

Sendo assim, explicaremos o código da linha $12$ em diante. A linha $12$, como também já visto, é um laço que terminará quando não existirem mais arestas reserva de nível $j$ (ou seja, quando o contador \textit{arestasReservasDeNível} do nó raiz de $T_u$ estiver nulo) ou quando achamos uma aresta substituta. 

A linha $13$ é onde acionamos o método \texttt{procureNóIncideArestaDePesoMínimo}, para obtermos um nó de vértice incidente a uma aresta reserva de peso mínimo. Assim, obtemos esta aresta chamando \texttt{consulteMinLAMSF} na linha $17$, onde obtemos um par ($y$, $w$). 

Em seguida, basta testarmos se a aresta $xy$ de peso mínimo $w$ é uma aresta substituta que reconecta $T_u$ a $T_v$. Para isso, na linha $18$ chamamos \texttt{testeSubstitutaMSF}, descrita no Programa~\ref{prog:find-substitute-MSF}.

\begin{programruledcaption}{\texttt{testeSubstitutaMSF($G$, $x$, $y$, $j$)} \label{prog:find-substitute-MSF}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$, as pontas $x$ e $y$ da aresta $xy$ e o nível $j$.\\
    \textbf{Saída}: Remove $xy$ de $R_j$ e, caso $xy$ seja substituta, adiciona $xy$ a $R_j$ e devolve verdadeiro. Caso contrário, adiciona $xy$ a $R_{j-1}$ e devolve falso.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \texttt{removaLAMSF($G.R_j$, $x$, $y$)}
    \texttt{atualizePesoMínimo($G.F_j$, $G.R_j$, $x$)}
    \texttt{atualizePesoMínimo($G.F_j$, $G.R_j$, $y$)}
    \textbf{se} \texttt{conectadosFD($G.F_j$, $x$, $y$)} \textbf{então} (*@\hfill $\triangleright$ a aresta xy não é substituta@*)
        $\dotvarm{G}{nível}{x, y}$ := j - 1
        w := $\dotvarm{G}{peso}{x, y}$
        \texttt{adicioneLAMSF($G.R_{j-1}$, $x$, $y$, $w$)}
        \texttt{atualizePesoMínimo($G.F_{j-1}$, $G.R_{j-1}$, $x$)}
        \texttt{atualizePesoMínimo($G.F_{j-1}$, $G.R_{j-1}$, $y$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{j-1}$, $G.R_{j-1}$, $x$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{j-1}$, $G.R_{j-1}$, $y$)}
        \textbf{retorne falso}
    \textbf{senão} (*@\hfill $\triangleright$ a aresta xy é substituta@*)
        L := $\dotvar{G}{nívelMax}$
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ + $w$ 
        \textbf{para} k := j \textbf{até} $L$ \textbf{faça}
            \texttt{adicioneFD($G.F_k$, $x$, $y$)}
        \textbf{se} x > y \textbf{então}
            x $\leftrightarrow$ y
        \texttt{atualizeÉNível($G.F_j$, $x$, $y$, $\textbf{verdadeiro}$)}
        \textbf{retorne verdadeiro}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Na rotina \texttt{testeSubstitutaMSF}, precisamos atualizar a variável \textit{pesoMSF} de $G$ quando encontramos uma aresta substituta, além de chamar os devidos métodos auxiliares (acionamos \texttt{removaLAMSF} e \texttt{adicioneLAMSF} em vez de \texttt{removaLA} e \texttt{adicioneLA}). Além disso, como estamos rebaixando arestas reserva, precisamos atualizar o atributo \textit{pesoMínimo} dos nós de vértice afetados, acionando a rotina \texttt{atualizePesoMínimo} nas linhas $2$, $3$, $8$ e $9$ do Programa~\ref{prog:find-substitute-MSF}.

Veja que as linhas $4$ a $12$ do Programa~\ref{prog:find-substitute-MSF} possuem custo amortizado $\Oh(\lg n)$. Isso quer dizer que, enquanto as arestas que estamos testando não forem substitutas, o método \texttt{testeSubstitutaMSF} será acionado várias vezes com esse custo de tempo. No momento em que encontrarmos uma substituta, \texttt{testeSubstitutaMSF} será acionado uma única vez e consumirá tempo amortizado $\Oh(\lg^2 n)$ por causa das linhas $16$ e $17$, e assim o algoritmo será finalizado. 

Agora, explicaremos o custo da rotina \texttt{substituaArestaMSF}. Usaremos o mesmo argumento da amortização da rotina \texttt{substituaAresta}, apresentado na Seção~\ref{sec:replace-edge}. 

No pior caso, uma execução da rotina \texttt{substituaArestaMSF} pode consumir muito tempo. Por exemplo, se o grafo já está com $m = \Theta(n^2)$ arestas inseridas, todas de nível $L$, pode ocorrer uma remoção que aciona o \texttt{substituaArestaMSF} e que acarreta o rebaixamento de $\Theta(n^2)$ arestas, a um custo $\Omega(n^2 \lg n)$. 

No entanto, para chegar a essa situação, teriam ocorrido $\Theta(n^2)$ inserções, cada uma com um custo bem mais barato, de $\Oh(\lg n)$. Isso sugere que possivelmente uma análise amortizada do custo das operações leve a um custo por operação mais baixo.

Agora mostraremos que, se ocorreram $t$ operações de inserção e remoção de arestas desde a criação do grafo, então o custo total de tal sequência de operações é $\Oh(t \lg^2 n)$, o que resulta em um custo amortizado por operação de $\Oh(\lg^2 n)$.

Para tanto, cada inserção será responsável não apenas pelo custo da inserção de uma aresta $e$, mas também pelo custo de todos os rebaixamentos sofridos por $e$ no decorrer de todas as remoções que ocorrerem após a inserção de $e$.
Isso quer dizer que a inserção da aresta $e$ vai pagar por cada execução das linhas $7$ a $11$ do Programa~\ref{prog:replaceMSF} e das linhas $2$ a $7$ do Programa~\ref{prog:find-substitute-MSF} que processa a aresta $e$. Como a inserção custa $\Oh(\lg n)$ e essas linhas custam $\Oh(\lg n)$ e são executadas $\Oh(\lg n)$ vezes, pois $e$ pode ser rebaixada no máximo $\left\lceil \lg n \right\rceil$ vezes, o custo pago por uma inserção é $\Oh(\lg^2 n)$.

Já uma remoção de aresta, executada pelo Programa~\ref{prog:removeGD-version-msf-final-version}, custa $\Oh(\lg^2 n)$ mais o custo do \texttt{substituaArestaMSF}. O custo do \texttt{substituaArestaMSF} é $\Oh(\lg^2 n)$ excluindo-se as execuções das linhas $7$ a $11$ do Programa~\ref{prog:replaceMSF}, como também as linhas $4$ a $12$ do Programa~\ref{prog:find-substitute-MSF}. Isso porque, desconsiderando estas linhas onde ocorrem rebaixamento de aresta, na linha $2$ do Programa~\ref{prog:replaceMSF} acaba tendo custo $\Oh(\lg n)$ nas linhas restantes. Apesar de as linhas $16$ e $17$ do Programa~\ref{prog:find-substitute-MSF} consumirem tempo $\Oh(\lg^2 n)$, este trecho do código será executado uma única vez quando encontrarmos a substituta e o algoritmo será finalizado. Assim, como a linha $2$ pode ser executada em no máximo $\Oh(\lg n)$ vezes, temos que \texttt{substituaAresta} consome tempo amortizado $\Oh(\lg^2 n)$ por operação de remoção.

Com isso, concluímos que o custo total da sequência de $t$ inserções e remoções é $\Oh(t \lg^2 n)$, e assim cada inserção e remoção consome tempo amortizado $\Oh(\lg^2 n)$.