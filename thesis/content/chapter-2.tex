%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Algoritmo para MSF decremental}

\enlargethispage{.8\baselineskip}

Neste capítulo, estudaremos o problema da árvore geradora mínima em grafos dinâmicos. 
Dado um grafo conexo $G$ com um custo associado a cada uma de suas arestas, 
o problema da árvore geradora mínima consiste em determinar uma árvore geradora
de G com custo mínimo, onde o custo de uma árvore é a soma dos custos de suas arestas. 
Como estamos interessados em grafos dinâmicos, é natural remover a restrição de que o 
grafo seja conexo, e neste caso considerar florestas geradoras maximais de custo mínimo 
(MSF, do inglês \emph{minimum spanning forest}). Chamamos um grafo com um custo 
associado a cada aresta de \textbf{grafo ponderado}. 

O problema da árvore geradora mínima em grafos ponderados (conexos) estáticos pode ser 
resolvido eficientemente, por exemplo, pelos algoritmos de Kruskal e de Prim. O algoritmo de Kruskal 
utiliza uma estrutura de dados clássica conhecida como union-find, enquanto que o algoritmo
de Prim utiliza uma fila de prioridades. Não há na literatura uma versão destes algoritmos 
para grafos dinâmicos. Isso talvez se deva à característica essencialmente sequencial destes
algoritmos, que modificam suas estruturas internas conduzidos por uma ordem de eventos.
Uma alteração no grafo poderia levar a uma alteração em toda a sequência de eventos 
nesses algoritmos a partir de um certo ponto, e com isso não há uma versão eficiente deles
que acomode alterações no grafo. 

Por outro lado, Holm, de Lichtenberg e Thorup~\cite{jacob_holm} propuseram uma adaptação do seu algoritmo para conexidade em 
grafos dinâmicos, apresentado no Capítulo 2, para que este mantenha, de maneira eficiente, 
uma floresta geradora maximal de custo mínimo em um grafo ponderado que pode sofrer 
remoções de arestas.  Ou seja, eles propuseram um algoritmo que resolve de maneira 
eficiente o problema que chamamos de MSF decremental.  Neste capítulo, descreveremos
esse algoritmo, que é uma adaptação do algoritmo descrito no Capítulo 2 para que este 
passe a resolver o problema da MSF decremental.  

\section{Biblioteca da MSF decremental}
\label{sec:decremental-msf-library}

Implementar o algoritmo decremental para florestas geradoras maximais de custo mínimo (MSF, de \textit{Minimum Spanning Forest}) resume-se à construção da seguinte biblioteca de forma eficiente:

\begin{itemize}
    \item \texttt{\textbf{MSFDecremental(n, E)}}: contrói e devolve um grafo ponderado $G$ com $n$ vértices e as arestas ponderadas dadas no conjunto $E$;
    \item \texttt{\textbf{consultePesoMSF(G)}}: devolve o peso da MSF do grafo ponderado $G$;
    \item \texttt{\textbf{removaMSF(G, u, v)}}: remove a aresta $uv$ do grafo ponderado $G$.
\end{itemize} 

Note que, diferente da biblioteca do algoritmo de conexidade em grafos dinâmicos, apresentada na Seção~\ref{sec:dynamic-graph-routines}, na MSF decremental não temos um método equivalente a \texttt{adicioneGD} disponível para o usuário. Em nossa implementação \cite{chung2025}, para criarmos um grafo $G$ de $n$ vértices e $m$ arestas ponderadas dadas em $E$, acionamos~ \texttt{MSFDecremental($n$,~$E$)}, onde criamos $\left\lceil \lg n \right\rceil$ florestas e $\left\lceil \lg n \right\rceil$ listas de adjacências com $n$ vértices isolados. Em seguida, ordenamos e inserimos essas $m$ arestas em ordem crescente de peso, usando uma biblioteca pronta do $\emph{C++}$ para ordená-las, que consome tempo esperado $\Oh(n \lg n)$. Estas $m$ arestas são  inseridas uma a uma acionando uma rotina que chamamos de  \texttt{adicioneMSF(u, v, w)}, onde $u$ e $v$ são pontas da aresta e $w$ é o peso dela.

A rotina \texttt{adicioneMSF} é acionada somente dentro do construtor. Por ser uma rotina privada, ou seja, não está disponível para o usuário, após a inserção destas arestas, não é permitido mais operações de inserção, somente de remoção de arestas. Para o usuário, então, só estarão disponíveis as rotinas \texttt{custoMSF} e \texttt{removaMSF}. A versão totalmente dinâmica, que inclui a rotina \texttt{adicioneMSF} para o usuário, será estudada posteriormente no Capítulo~\ref{chapter:fully-MSF}.

O construtor \texttt{MSFDecremental}, devido à ordenação de arestas, possui consumo de tempo $\Oh(n \lg n)$. Já a rotina \texttt{custoMSF} possui consumo de tempo $\Oh(1)$. Como estes dois métodos são mais simples, passaremos brevemente sobre eles, e detalharemos mais a rotina \texttt{removaMSF}, que possui a rotina auxiliar \texttt{substituaArestaMSF} implementada de maneira diferente do \texttt{substituaAresta} do algoritmo de conexidade em grafos dinâmicos. 

Usaremos várias definições já apresentadas no algoritmo de conexidade dinâmica em grafos dinâmicos, incluindo as mesmas invariantes apresentadas na Seção~\ref{sec:level-slicing}, os mesmos tipos de arestas da Seção~\ref{sec:dynamic-graph-edge-types} e nós das florestas apresentados na Seção~\ref{sec:graph-nodes}. A seguir, apresentaremos as rotinas da MSF decremental e alguns ajustes a serem feitos. 

\subsection{Listas de adjacências}
\label{sec:adjancency-lists-min-heap}

Na Seção~\ref{sec:dynamic-graph-edge-types}, apresentamos a biblioteca de \texttt{listasDeAdjacências}, onde usamos um mapa hash para inserir ou remover um vértice $v$ da lista de $u$, além de percorrer os vizinhos da lista de $u$. No algoritmo da MSF decremental, quando removemos uma aresta de nível $i$ da floresta $F_i$, uma componente desta será quebrada em duas, $T_u$ e $T_v$, da mesma forma que no algoritmo de conexidade em grafos dinâmicos. A diferença é que, no caso da MSF decremental, precisamos buscar por uma aresta substituta que tenha o menor peso e que ligue $T_u$ a~$T_v$. Não podemos simplesmente percorrer todos os vizinhos $y$ de cada vértice $x$ em $T_u$, verificar se $xy$ reconecta as componentes separadas e se é de menor peso dentre todas as substitutas, já que isso seria ineficiente.

Assim, fica claro que seria bom percorrer as arestas reservas em ordem crescente de peso e testar se alguma é substituta nesta ordem. Por isso, em vez de usar um mapa hash para armazenar os vizinhos de cada vértice, usaremos um min-heap. Na verdade, como estamos trabalhando com nós de vértice e de aresta, cada nó de vértice $u$ guardará um min-heap com os vizinhos de $u$ em $R_i$, onde a chave dessa estrutura de dados para um vizinho $v$ será o peso da aresta $uv$. Nós de aresta também guardarão um min-heap, porém vazio. 

Os métodos principais (remoção, inserção e extração da chave mínima) que usamos no min-heap consomem tempo O($\lg n)$ usando uma implementação tradicional de heap, como a descrita no Capítulo 6 de Thomas H. Cormen et al. \cite{clrs}. O resto dos métodos consomem tempo constante, e eles serão necessários para buscar a aresta substituta de peso, como descreveremos mais à frente.

Como o min-heap é uma estrutura de dados bastante conhecida, não iremos descrever a sua implementação em detalhes. O objetivo é ressaltar as diferenças entre as listas de adjacências utilizadas no algoritmo de conexidade em grafos dinâmicos e na MSF decremental, e como essa mudança afetará o comportamento do método \texttt{substituaArestaMSF} da MSF decremental.

Assim, com base na implementação clássica do min-heap, podemos definir a biblioteca das listas de adjacências da MSF decremental. 

\begin{itemize}
    \item \texttt{\textbf{listasDeAdjacênciasMSF(n)}}: constrói e devolve um grafo com $n$ vértices e sem arestas, representado por listas de adjacências;
    \item \texttt{\textbf{adicioneLAMSF(R, u, v, w)}}: adiciona o vértice $u$ na lista de adjacências de $v$ em $R$ e vice-versa, considerando que o peso de $uv$ é $w$;
    
    \item \texttt{\textbf{removaLAMSF(R, u, v)}}: remove o vértice $u$ da lista de adjacências de $v$ em $R$ e vice-versa;
    
    \item \texttt{\textbf{consulteMinLAMSF(R, u)}}: retorna o par $\{v, p\}$, onde $v$ é vértice do min-heap de $u$ em $R$ com chave mínima $w$;

    \item \texttt{\textbf{extraiaMinLAMSF(R, u)}}: remove e retorna o par $\{v, p\}$, onde $v$ é vértice do min-heap de $u$ em $R$ com chave mínima $w$.
\end{itemize} 

Uma chamada à rotina \texttt{adicioneLAMSF(R, u, v, w)} adiciona o par $\{u, p\}$ no min-heap de $v$, como também adiciona o par $\{v, p\}$ no min-heap de $u$, consumindo tempo $\Oh(\lg n)$. Similarmente, uma chamada à rotina \texttt{removaLAMSF(R, u, v)} remove o par $\{u, p\}$ do min-heap de $v$, como também remove o par $\{v, p\}$ do min-heap de $u$, consumindo também tempo $\Oh(\lg n)$. 

O método \texttt{consulteMinLAMSF} consome tempo $\Oh(1)$, já que estamos apenas consultando a chave mínima do min-heap de um vértice. Já o método \texttt{extraiaMinLAMSF} consome tempo $\Oh(\lg n)$, já que estamos extraindo a chave mínima do min-heap de um vértice. Ambos serão utilizados quando descrevermos ajustes nos nós da floresta e também no método \texttt{substituaArestaMSF}.

\section{Ajustes nas invariantes}

Como agora estamos tratando de florestas geradoras maximais de custo mínimo (MSFs), ajustaremos somente a primeira invariante, onde substituímos o termo floresta maximal por MSF, como se pode ver abaixo.

\begin{enumerate}[label=(\Roman*)]
    \item \label{invariant11} $F_i$ é uma MSF de $G_i$ para todo $1 \leq i \leq  \left\lceil \lg n \right\rceil$;
    
    \item \label{invariant22} $F_i \subseteq F_{i+1}$ para todo $1 \leq i \leq \left\lceil \lg n \right\rceil - 1$;
    
    \item \label{invariant33} Cada componente da floresta $F_i$ possui no máximo $2^i$ vértices.
\end{enumerate}

A partir deste momento, usaremos estas três invariantes e mostraremos como elas são preservadas no decorrer das modificações no grafo.

\section{Rotinas da biblioteca da MSF decremental}

\subsection{Criação do grafo}

O construtor \texttt{MSFDecremental} é bem parecido com o do grafo dinâmico, descrito na Seção~\ref{sec:dynamic-graph-creation}. Além das variáveis de classe existentes que criamos para o grafo $G$ no algoritmo de conexidade em grafos dinâmicos, armazenaremos o peso da MSF decremental numa variável chamada \textit{pesoMSF}, que será simplesmente retornada quando consultarmos o peso da MSF decremental corrente chamando \texttt{consultePesoMSF}.

Também incluiremos um atributo do grafo chamado \textit{peso}, que é um mapa hash que armazena o peso das arestas. Para armazenar o peso $w$ de uma aresta $uv$, basta chamarmos $ \dotvar{G}{peso[u, v]} \leftarrow w$. O atributo \textit{peso} será fundamental para recalcular a variável \textit{pesoMSF} no decorrer das remoções do grafo.

Dessa forma, podemos apresentar o construtor da MSF decremental no Programa~\ref{prog:newDecrementalMSF}.

\begin{programruledcaption}{\texttt{MSFDecremental($n$, $E$)} \label{prog:newDecrementalMSF}}
    \noindent\textbf{Entrada}: Recebe o número $n$ de vértices do grafo e um conjunto de arestas $E$. \\
    \textbf{Saída}: Devolve um grafo $G$ com $n$ vértices e $m$ arestas ponderadas.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\left\lceil \lg n \right\rceil$
    $\dotvar{G}{nívelMax}$ := L
    $G.pesoMSF$ := 0
    \textbf{para} $i$ := $1$ \textbf{até} $L$ \textbf{faça}
        $G.F_i$ := \texttt{florestaDinâmica($n$)}
        $G.R_i$ := \texttt{listasDeAdjacênciasMinHeap($n$)}
    $\dotvar{G}{nível}$ := \texttt{novoMapaHash($n$)}
    $\dotvar{G}{peso}$ := \texttt{novoMapaHash($n$)}
    \texttt{ordene($E$)} (*@\hfill $\triangleright$ ordena as arestas do conjunto $E$ em ordem crescente@*)
    \textbf{para cada aresta} ($u$, $v$, $w$) \textbf{em} $E$ \textbf{faça}
        \texttt{adicioneMSF}($G$, $u$, $v$, $w$)
    \textbf{retorne} G
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Podemos notar algumas diferenças quando comparamos o construtor \texttt{MSFDecremental} com o \texttt{grafoDinâmico}. Na MSF decremental, além de inicializarmos $\left\lceil \lg n \right\rceil$ listas de adjacências e $\left\lceil \lg n \right\rceil$ florestas dinâmicas, ordenamos as arestas do conjunto $E$ em ordem crescente de peso e inserimos uma a uma chamando \texttt{adicioneMSF}, que está descrito abaixo.

\begin{programruledcaption}{\texttt{adicioneMSF($G$, $u$, $v$, $w$)} \label{prog:addMSF}}
    \noindent\textbf{Entrada}: Recebe dois vértices $u$ e $v$ do grafo $G$, com $u < v$, e o peso $w$ da aresta $uv$. \\
    \textbf{Efeito}: Adiciona a aresta $uv$ de peso $w$ no grafo $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    $\dotvarm{G}{nível}{u,v}$ := $L$
    $\dotvar{G}{peso[u, v]}$ := p
    \textbf{se} \texttt{conectadosFD($G.F_{L}$, $u$, $v$)} \textbf{então} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{adicioneLAMSF($G.R_{L}$, $u$, $v$, $w$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $u$)}
        \texttt{incrementeArestasReservasDeNível($G.F_{L}$, $G.R_{L}$, $v$)}
    \textbf{senão}
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ + w
        \texttt{adicioneFD($G.F_L$, $u$, $v$)}
        \texttt{atualizeÉNível($G.F_L$, $u$, $v$, $\textbf{verdadeiro}$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

Como citado antes, a rotina \texttt{adicioneMSF} é acionada apenas em \texttt{MSFDecremental}. Ademais, a única diferença entre a \texttt{adicioneMSF} e a \texttt{adicioneGD} que vimos é que, na primeira, estamos guardando o peso das arestas quando as inserimos no grafo. Portanto, \texttt{adicioneMSF} também consome tempo amortizado $\Oh(\lg n)$.


Para \texttt{adicioneMSF}, a invariante~\ref{invariant11} é preservada para o nível $i = \left\lceil \lg n \right\rceil$. Como estamos inserindo arestas de nível $\left\lceil \lg n \right\rceil$ em $F_{\left\lceil \lg n \right\rceil}$, então as florestas de níveis inferiores não são afetadas, mantendo-se, assim, as invariantes~\ref{invariant22} e \ref{invariant33} também.

\subsection{Consulta de peso da MSF decremental}
\label{sec:connectivity-test-MSF}

A rotina \texttt{consultePesoMSF}, que devolve o peso da MSF do grafo $G$, está descrita abaixo.     

\begin{programruledcaption}{\texttt{consultePesoMSF($G$)} \label{prog:extract-weight-MSF}}
    \noindent\textbf{Entrada}: Recebe o grafo $G$. \\
    \textbf{Saída}: Devolve o peso da MSF de $G$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    \textbf{retorne} $\dotvar{G}{pesoMSF}$
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

\raggedbottom

É fácil ver que \texttt{consultePesoMSF} consome tempo $\Oh(1)$. Além disso, como não estamos alterando as MSFs de $G$, então as três invariantes são preservadas.

\subsection{Remoção de arestas na MSF decremental}
\label{sec:decremental-MSF-edge-removal}

A remoção de arestas também é semelhante à do algoritmo de conexidade em grafos dinâmicos. A diferença é que a busca por alguma aresta substituta, feita na \texttt{substituaArestaMSF} agora, é dada por ordem crescente de peso das arestas reserva. 

Quando removemos uma aresta $uv$ de nível $i$ em $F_i$, quebramos uma componente desta floresta em $T_u$ e $T_v$, com $|T_u| \leq |T_v|$, e rebaixamos todas as arestas de $T_u$, da mesma forma como fazíamos antes em \texttt{substituaAresta}. Porém, agora buscamos alguma aresta reserva de peso dentre todas as arestas reserva em $R_i$ incidente a $T_u$, e testamos se ela é uma substituta. Se não é, a rebaixamos para $R_{i-1}$ e buscamos a próxima de peso em $R_i$ incidente a $T_u$. Assim, quando achamos uma substituta, conseguimos manter o peso da MSF do grafo e ainda reconectar as duas componentes separadas devido à remoção de $uv$. 

Para facilitar o entendimento da substituição de aresta na MSF decremental, demonstraremos a remoção de uma aresta $uv$ da floresta em uma série de imagens. Na Figura~\ref{fig:example-replacement-msf1}, temos um grafo ponderado $G$ e assumiremos que, até o momento, só houve inserções de arestas. 

No nosso exemplo, $G$ tem $n = 10$ vértices. Sabemos que $\left\lceil \lg 10 \right\rceil = 4$, logo o nível máximo $L$ da floresta é $4$ e,  consequentemente, $G = G_4$. Como todas as inserções só ocorrem no nível $L$ em $F_4$, só temos arestas da floresta de nível $4$, enquanto $F_3$ contém apenas vértices isolados. Neste cenário, note que a remoção da aresta $uv$ da floresta, representada por uma linha tracejada na figura, acaba quebrando a única componente da floresta $F_4$ em duas, $T_u$ e $T_v$. Como $F_4$ é a floresta maximal de nível máximo de $G$, então removemos somente a $uv$ de $F_4$. 

\tikzset{weight/.style={font=\small, inner sep=1pt, fill=white}}

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[removed] (u) -- (v) node[midway, above, weight] {9};
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            %\draw[edge] (a) -- (u) node[midway, below] {};
            %\draw[edge] (a) -- (b) node[midway, below] {};
            %\draw[edge] (b) -- (c) node[midway, below] {};

        \end{tikzpicture}
    \end{minipage}
    \caption{Um grafo ponderado $G$ de 10 vértices, onde as arestas pretas são da floresta $F_4$, enquanto as vermelhas são reservas. A aresta $uv$ está prestes a ser removida. A floresta $F_{4}$ de $G$ de cima contém todas as arestas pretas recém-inseridas e as arestas vermelhas estão em $R_4$. A floresta de baixo é a $F_{3}$, com os vértices isolados, e $R_3$ também não tem nenhuma aresta.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf1}
\end{figure}

O próximo passo é rebaixar todas as arestas de nível~$4$ em $T_u$ para o nível~$3$. Dessa forma, as arestas de $T_u$ passam a estar em $F_3$, como se pode ver na Figura~\ref{fig:example-replacement-msf2}, pois agora elas passam a ser de nível $3$.  

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};

        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da remoção da aresta $uv$ em $G$. As arestas de nível $4$ de $T_u$ foram rebaixadas para o nível $3$, o que pode ser visto na floresta $F_{3}$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf2}
\end{figure}

Como $T_u$ e $T_v$ em $F_4$ ficaram separadas após a remoção de $uv$, precisamos encontrar, se existir, uma aresta reserva que possa reconectá-las. Note que agora precisamos percorrer as arestas reserva em ordem de peso. Entretanto, percorrer todas as arestas reserva de $R_4$ incidentes a $T_u$ e selecionar a de menor peso é ineficiente, e por isso explicaremos como implementar essa busca por uma aresta substituta de menor peso na Seção~\ref{sec:forest-node-adjustments}.

Na Figura~\ref{fig:example-replacement-msf3}, percorremos as arestas reserva em ordem de peso em $R_4$ que tenham uma das pontas em~$T_u$. Para cada aresta percorrida, verificamos se a outra ponta dela incide em algum vértice de $T_v$. No nosso exemplo, olhamos para as arestas reserva em $R_4$, antes de encontrarmos a substituta, nesta ordem: $bu$ (peso $12$) e $uc$ (peso~$13$). Veja  que as rebaixamos para $R_3$ por não serem substitutas.

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[reserve] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (a) -- (c) node[midway, above, yshift=10pt, weight] {16};
        
        \draw[reserveremoved] (b) -- (u) node[midway, above, xshift=15pt, yshift = -2pt, weight] {12};
        \draw[reserveremoved] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted


        \end{tikzpicture}
    \end{minipage}
    \caption{Representação da busca por uma aresta substituta em $R_4$. As arestas reserva de nível $4$ que estão tracejadas foram percorridas em ordem crescente de peso e estão prestes a ser removidas de $R_4$, pois foram rebaixadas para o nível $3$, como se pode ver em $R_3$.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf3}
\end{figure}

Assim, a próxima aresta reserva de menor peso em $R_4$ que olharemos é a $ad$, de peso $14$. Como ela conecta $T_u$ a $T_v$, chamamos \texttt{adicioneFD($F_4$, $a$, $d$, $14$)} e $ad$ passa a ser uma aresta da floresta, ou seja, é removida de $R_4$. Como $i = 4$ é o nível máximo do grafo nesse exemplo, não precisamos chamar esta rotina para os níveis superiores e então terminamos a execução do algoritmo. A Figura~\ref{fig:example-replacement-msf4} ilustra essa etapa do algoritmo. 

\begin{figure}[H]
    \centering

    \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $4$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
        [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed},
        reserveremoved/.style={red, thick, dashed}]

        \node[node] (u) at (-1,2) {$u$};
        \node[node] (a) at (-3,4) {$a$};
        \node[node] (b) at (-5,2) {$b$};
        \node[node] (c) at (-3,0) {$c$};
        \node[node] (v) at (2,2) {$v$};
        \node[node] (d) at (3,3.7) {$d$};
        \node[node] (e) at (3,0.3) {$e$};
        \node[node] (f) at (5,0.3) {$f$};
        \node[node] (g) at (6, 2) {$g$};
        \node[node] (h) at (5, 3.7) {$h$};
        
         % Dotted circles for T_u and T_v
        \draw[dotted, thick, gray] (-3,2) circle (2.7cm);
        \draw[dotted, thick, gray] (4,2) circle (2.7cm);  
        
        % Labels for the circles
        \node at (-3,-1.1) {$T_u$};
        \node at (4,-1.1) {$T_v$};

        \draw[edge] (a) -- (u) node[midway, above, weight] {1};
        \draw[edge] (a) -- (b) node[midway, above, weight] {2};
        \draw[edge] (b) -- (c) node[midway, above, weight] {3};
        \draw[edge] (v) -- (d) node[pos=0.45, above, yshift=-2pt, weight] {4}; % adjusted
        \draw[edge] (v) -- (f) node[midway, above, weight] {5};
        \draw[edge] (v) -- (e) node[midway, above, yshift=-3pt, weight] {6}; % adjusted
        \draw[edge] (f) -- (g) node[midway, above, yshift=-3pt, weight] {7}; % adjusted
        \draw[edge] (g) -- (h) node[midway, below, yshift=3pt, weight] {8}; % adjusted

        % reserve edges (normal red edges)
        \draw[edge] (a) -- (d) node[midway, above, yshift=0pt, weight] {14};
        \draw[reserve] (c) -- (v) node[pos=0.6, below, yshift=-1pt, weight] {15}; % adjusted
        \draw[reserve] (a) -- (c) node[midway, above, yshift=0pt, weight] {16};
        \draw[reserve] (d) -- (f) node[midway, above, yshift=-1pt, weight] {10}; % adjusted
        \draw[reserve] (d) -- (h) node[midway, above, yshift=-1pt, weight] {11};

        \end{tikzpicture}
    \end{minipage}
    \vspace{1cm}
        \noindent
    \begin{minipage}[c]{2cm}
        \raggedright
        Nível $3$
    \end{minipage}%
    \begin{minipage}[c]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
            [scale=0.6, node/.style={scale=0.7, circle,draw,minimum size=2em, thick, font=\large},
            edge/.style={thick, black},
            reserve/.style={red, thick},
            removed/.style={black, thick, dashed}]

            \node[node] (u) at (-1,2) {$u$};
            \node[node] (a) at (-3,4) {$a$};
            \node[node] (b) at (-5,2) {$b$};
            \node[node] (c) at (-3,0) {$c$};
            \node[node] (v) at (2,2) {$v$};
            \node[node] (d) at (3,3.7) {$d$};
            \node[node] (e) at (3,0.3) {$e$};
            \node[node] (f) at (5,0.3) {$f$};
            \node[node] (g) at (6, 2) {$g$};
            \node[node] (h) at (5, 3.7) {$h$};
            
            \draw[edge] (a) -- (u) node[midway, above, weight] {1};
            \draw[edge] (a) -- (b) node[midway, above, weight] {2};
            \draw[edge] (b) -- (c) node[midway, above, weight] {3};
                    \draw[reserve] (b) -- (u) node[midway, above, yshift=-1pt, weight] {12};
        \draw[reserve] (c) -- (u) node[pos=0.4, above, yshift=-2pt, weight] {13}; % adjusted


        \end{tikzpicture}
    \end{minipage}
    \caption{Representação do grafo com a aresta substituta $ad$ por ser a de menor peso em $R_4$ que conecta $T_u$ a $T_v$ em $F_4$, tornando-se uma aresta da floresta.}
    \vspace{-1cm}
    \label{fig:example-replacement-msf4}
\end{figure}



































A partir dessas imagens, percebe-se que o método \texttt{removaMSF}, descrito abaixo, é bem semelhante ao método \texttt{removaGD}, exceto que no primeiro precisamos recalcular o peso da MSF de $G$ quando removemos uma aresta da floresta.

\begin{programruledcaption}{\texttt{removaMSF($G$, $u$, $v$)} \label{prog:removeGD-version-msf}}
    \noindent\textbf{Entrada}: Recebe dois vértices adjacentes $u$ e $v$ do grafo $G$. \\
    \noindent\textbf{Efeito}: Remove a aresta $uv$ do grafo $G$. 
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    L := $\dotvar{G}{nívelMax}$
    i := $\dotvarm{G}{nível}{u,v}$
    $\dotvarm{G}{nível}{u,v}$ := \texttt{NIL} (*@\hfill $\triangleright$ marcamos $uv$ como removida@*)
    \textbf{se} uv $\in$ G.$F_{L}$ \textbf{então}  (*@\hfill $\triangleright$ $uv$ é aresta da floresta@*)
        w := $\dotvar{G}{peso[u][v]}$
        $\dotvar{G}{pesoMSF}$ := $\dotvar{G}{pesoMSF}$ - $w$
        \textbf{para} j := i \textbf{até} L \textbf{faça}
            \texttt{removaFD($G.F_j$, $u$, $v$)}
        \texttt{substituaArestaMSF($G$, $i$, $u$, $v$)}
    \textbf{senão} (*@\hfill $\triangleright$ $uv$ é aresta reserva@*)
        \texttt{removaLAMSF($G.R_i$, $u$, $v$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $u$)}
        \texttt{decrementeArestasReservasDeNível($G.F_i$, $G.R_i$, $v$)}
    \end{lstlisting}
    \vspace{-0.5\baselineskip}
\end{programruledcaption}

O método \texttt{substituaArestaMSF}, que é uma versão ajustada de \texttt{substituaAresta}, será descrito mais adiante. Por enquanto, sabemos que \texttt{removaMSF} consome tempo $\Oh(\lg^2 n)$ mais o custo de \texttt{substituaArestaMSF}.

\subsection{Ajustes em nós da floresta}
\label{sec:forest-node-adjustments}

No algoritmo de conexidade em grafos dinâmicos, vimos que os nós da floresta guardam dois campos, \textit{incideArestaReservaDeNível} e \textit{éNível}, além de dois contadores, \textit{arestasDeNível} e \textit{arestasReservasDeNível}. Mostramos também alguns métodos que atualizam estes campos e que usam estes campos para realizar a busca eficiente de arestas reserva quando procuramos por alguma aresta substituta.

Para o algoritmo da MSF decremental, além destes campos apresentados, precisaremos de dois campos extras para cada nó da floresta: \textit{peso} e \textit{pesoMínimo}. O primeiro campo indica o peso de um nó de aresta (nós de vértice guardam $\infty$ neste campo). O segundo campo guarda o peso mínimo dentre todas as arestas reserva em cada $R_i$, pois é assim que conseguimos extrair a aresta reserva de peso mínimo quando estamos buscando uma substituta. Assim, o peso mínimo de um nó é calculado através do peso mínimo dos nós em sua subárvore.

Como o peso de cada aresta ponderada nunca muda após a sua inserção, então não precisamos atualizar o seu peso. Entretanto, à medida que vamos removendo arestas da floresta $F_i$, quebramos alguma componente dela em duas e precisamos buscar alguma aresta substituta para reconectar as duas componentes separadas. Assim, quando procuramos por alguma aresta reserva em $R_i$, podemos neste processo rebaixar algumas para $R_{i-1}$ onde o \textit{pesoMínimo} em $R_{i-1}$ precisa ser atualizado. Se em $R_i$ encontrarmos uma substituta, ela se tornará uma aresta da floresta e a precisamos atualizar o \textit{pesoMínimo} em $R_i$, que agora será o peso mínimo dentre as arestas reserva restantes.

Por isso, fica claro que precisamos de um método que atualize \textit{pesoMínimo}. Na nossa implementação, a atualização deste atributo é feita na operação \texttt{splay}, sempre que essa executa uma rotação. O método \texttt{atualizePesoMínimo} está descrito abaixo.

\begin{programruledcaption}{\texttt{atualizePesoMínimo($\emph{p}$)} \label{prog:updateMinWeight}}
    \noindent\textbf{Entrada}: Recebe um nó $p$.\\
    \noindent\textbf{Efeito}: Atualiza o atributo \textit{pesoMínimo} de $p$.
    \vspace{-0.5\baselineskip}
    \begin{lstlisting}[
        language={[brazilian]pseudocode},
        style=pseudocode,
        style=wider,
        functions={},
        specialidentifiers={},
        escapeinside={(*@}{@*)},
    ]
    c := $\infty$ 
    \textbf{se} p.esq $\neq$ \texttt{NIL} \textbf{e} \textit{p.esq.pesoMínimo} < c \textbf{então}
        c := \textit{p.esq.pesoMínimo}
    \textbf{se} p.dir $\neq$ \texttt{NIL} \textbf{e} \textit{p.dir.pesoMínimo} < c \textbf{então}
        c := \textit{p.dir.pesoMínimo}
    \textbf{se} R[p] $\neq \emptyset$  \textbf{então}
        (v, w) := \texttt{consulteMinLAMSF(R, u)}
        \textbf{se} w < c \textbf{então}
            c := w
    p.pesoMínimo := c
\end{lstlisting}
\vspace{-0.5\baselineskip}
\end{programruledcaption}

Como se pode ver, o Programa~\ref{prog:updateMinWeight} consome tempo $\Oh(1)$. Além disso, ele não altera a floresta $F_i$, altera somente uma das árvores binárias que a representam. Portanto, todas as três invariantes são preservadas.

Para entendermos como estes dois campos extras aparecem em cada nó da floresta, usaremos um exemplo de um grafo ponderado $G$ de $5$ vértices e $7$ arestas ponderadas, como se pode ver na Figura~\ref{fig:generic-graph-example-1}. A Figura~\ref{fig:euler-tour-balanced-field-propagation-1} mostra estes campos nos nós da floresta $F_L$ de $G$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node] (a) at (0,0) {$a$};
        \node[node] (b) at (1.5,1.5) {$b$};
        \node[node] (c) at (3,0) {$c$};
        \node[node] (d) at (1.5,-1.5) {$d$};
        \node[node] (e) at (-1.5,-1.5) {$e$};

        \draw[edge] (a) -- (b) node[midway, above, weight] {1};;
        \draw[edge] (c) -- (d) node[midway, above, weight] {2};;
        \draw[edge] (d) -- (a) node[midway, above, weight] {3};;
        \draw[edge] (a) -- (e) node[midway, above, weight] {4};;

        \draw[reserve] (e) -- (d) node[midway, above, weight] {5};
        \draw[reserve] (b) -- (c) node[midway, above, weight] {6};
        \draw[reserve] (a) -- (c) node[midway, above, weight] {7};


    \end{tikzpicture}
    \caption{Grafo ponderado $G$ de $5$ vértices e $7$ arestas ponderadas. Arestas pretas são da floresta e formam a MSF de $G$, enquanto as vermelhas são arestas reserva.}
    \label{fig:generic-graph-example-1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [scale=0.8, node/.style={circle,draw,minimum size=2em, thick, font=\large},
        edge/.style={thick, black},
        reserve/.style={red, thick},
        removed/.style={black, thick, dashed}, 
        inner sep=0pt]

        \node[node, label=below:{(3, 5)}] (ad) at (0, 0) {$ad$};
        \node[node, label=below:{(1, 5)}] (ab) at (-4.5, -1.5) {$ab$};
        \node[node, label=below:{(2, 5)}] (cd) at (4.5, -1.5) {$cd$};
        \node[node, label=below:{(2, 5)}] (dc) at (3, -3) {$dc$};
        \node[node, label=below:{($\infty$, $5$)}] (dd) at (1.5, -4.5) {$dd$};
        \node[node, label=below:{($\infty$, $6$)}] (cc) at (4.5, -4.5) {$cc$};
        
        
        \node[node, label=below:{(3, $\infty$)}] (da) at (6, -3) {$da$};
        \node[node, label=below:{(4, $\infty$)}] (ae) at (7.5, -4.5) {$ae$};
        
        
        \node[node, label=below:{(4, 5)}] (ea) at (-6, -3) {$ea$};
        \node[node, label=below:{($\infty$, 5)}] (ee) at (-7.5, -4.5) {$ee$};
        \node[node, label=below:{($\infty$, 7)}] (aa) at (-4.5, -4.5) {$aa$};


        \node[node, label=below:{($\infty$, 6)}] (bb) at (-3, -3) {$bb$};
        \node[node, label=below:{(1, $\infty$)}] (ba) at (-1.5, -4.5) {$ba$};

        

        % tree edges (normal black edges)
        \draw[edge] (ad) -- (ab) node[midway, below] {};
        \draw[edge] (ad) -- (cd) node[midway, below] {};
        \draw[edge] (cd) -- (dc) node[midway, below] {};
        \draw[edge] (cd) -- (da) node[midway, below] {};
        \draw[edge] (bb) -- (ba) node[midway, below] {};
        \draw[edge] (ea) -- (ee) node[midway, below] {};
        \draw[edge] (ea) -- (aa) node[midway, below] {};
        \draw[edge] (dc) -- (dd) node[midway, below] {};
        \draw[edge] (dc) -- (cc) node[midway, below] {};
        \draw[edge] (da) -- (ae) node[midway, below] {};

        \draw[edge] (ab) -- (ea) node[midway, below] {};
        \draw[edge] (ab) -- (bb) node[midway, below] {};


    \end{tikzpicture}
    \caption{Árvore da única componente da floresta $F_L$ do grafo $G$ da Figura~\ref{fig:generic-graph-example-1}, onde embaixo de cada nó contém um par de números. O primeiro número indica o atributo \textit{peso} do nó, enquanto o segundo número indica o \textit{pesoMínimo} na subárvore do nó.}
    \label{fig:euler-tour-balanced-field-propagation-1}
\end{figure}